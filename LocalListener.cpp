#include "LocalListener.h"
#include <unistd.h>
#include <fstream>
#include <errno.h>

LocalListener* gLListener;

typedef websocketpp::server<websocketpp::config::asio> server;
using websocketpp::connection_hdl;
using websocketpp::lib::placeholders::_1;
using websocketpp::lib::placeholders::_2;
using websocketpp::lib::bind;

using websocketpp::lib::thread;
using websocketpp::lib::mutex;
using websocketpp::lib::lock_guard;
using websocketpp::lib::unique_lock;
using websocketpp::lib::condition_variable;


void SendDistrubuteServer(user_container *container, char *json);
char byte_30EF50[16] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F };
DWORD dword_3D0EF10[256] = { 0, 0x4C11DB7, 0x9823B6E, 0xD4326D9, 0x130476DC, 0x17C56B6B
,0x1A864DB2, 0x1E475005, 0x2608EDB8, 0x22C9F00F, 0x2F8AD6D6
,0x2B4BCB61, 0x350C9B64, 0x31CD86D3, 0x3C8EA00A, 0x384FBDBD
,0x4C11DB70, 0x48D0C6C7, 0x4593E01E, 0x4152FDA9, 0x5F15ADAC
,0x5BD4B01B, 0x569796C2, 0x52568B75, 0x6A1936C8, 0x6ED82B7F
,0x639B0DA6, 0x675A1011, 0x791D4014, 0x7DDC5DA3, 0x709F7B7A
,0x745E66CD, 0x9823B6E0, 0x9CE2AB57, 0x91A18D8E, 0x95609039
,0x8B27C03C, 0x8FE6DD8B, 0x82A5FB52, 0x8664E6E5, 0xBE2B5B58
,0xBAEA46EF, 0xB7A96036, 0xB3687D81, 0xAD2F2D84, 0xA9EE3033
,0xA4AD16EA, 0xA06C0B5D, 0xD4326D90, 0xD0F37027, 0xDDB056FE
,0xD9714B49, 0xC7361B4C, 0xC3F706FB, 0xCEB42022, 0xCA753D95
,0xF23A8028, 0xF6FB9D9F, 0xFBB8BB46, 0xFF79A6F1, 0xE13EF6F4
,0xE5FFEB43, 0xE8BCCD9A, 0xEC7DD02D, 0x34867077, 0x30476DC0
,0x3D044B19, 0x39C556AE, 0x278206AB, 0x23431B1C, 0x2E003DC5
,0x2AC12072, 0x128E9DCF, 0x164F8078, 0x1B0CA6A1, 0x1FCDBB16
,0x18AEB13, 0x54BF6A4, 0x808D07D, 0xCC9CDCA, 0x7897AB07
,0x7C56B6B0, 0x71159069, 0x75D48DDE, 0x6B93DDDB, 0x6F52C06C
,0x6211E6B5, 0x66D0FB02, 0x5E9F46BF, 0x5A5E5B08, 0x571D7DD1
,0x53DC6066, 0x4D9B3063, 0x495A2DD4, 0x44190B0D, 0x40D816BA
,0xACA5C697, 0xA864DB20, 0xA527FDF9, 0xA1E6E04E, 0xBFA1B04B
,0xBB60ADFC, 0xB6238B25, 0xB2E29692, 0x8AAD2B2F, 0x8E6C3698
,0x832F1041, 0x87EE0DF6, 0x99A95DF3, 0x9D684044, 0x902B669D
,0x94EA7B2A, 0xE0B41DE7, 0xE4750050, 0xE9362689, 0xEDF73B3E
,0xF3B06B3B, 0xF771768C, 0xFA325055, 0xFEF34DE2, 0xC6BCF05F
,0xC27DEDE8, 0xCF3ECB31, 0xCBFFD686, 0xD5B88683, 0xD1799B34
,0xDC3ABDED, 0xD8FBA05A, 0x690CE0EE, 0x6DCDFD59, 0x608EDB80
,0x644FC637, 0x7A089632, 0x7EC98B85, 0x738AAD5C, 0x774BB0EB
,0x4F040D56, 0x4BC510E1, 0x46863638, 0x42472B8F, 0x5C007B8A
,0x58C1663D, 0x558240E4, 0x51435D53, 0x251D3B9E, 0x21DC2629
,0x2C9F00F0, 0x285E1D47, 0x36194D42, 0x32D850F5, 0x3F9B762C
,0x3B5A6B9B, 0x315D626, 0x7D4CB91, 0xA97ED48, 0xE56F0FF
,0x1011A0FA, 0x14D0BD4D, 0x19939B94, 0x1D528623, 0xF12F560E
,0xF5EE4BB9, 0xF8AD6D60, 0xFC6C70D7, 0xE22B20D2, 0xE6EA3D65
,0xEBA91BBC, 0xEF68060B, 0xD727BBB6, 0xD3E6A601, 0xDEA580D8
,0xDA649D6F, 0xC423CD6A, 0xC0E2D0DD, 0xCDA1F604, 0xC960EBB3
,0xBD3E8D7E, 0xB9FF90C9, 0xB4BCB610, 0xB07DABA7, 0xAE3AFBA2
,0xAAFBE615, 0xA7B8C0CC, 0xA379DD7B, 0x9B3660C6, 0x9FF77D71
,0x92B45BA8, 0x9675461F, 0x8832161A, 0x8CF30BAD, 0x81B02D74
,0x857130C3, 0x5D8A9099, 0x594B8D2E, 0x5408ABF7, 0x50C9B640
,0x4E8EE645, 0x4A4FFBF2, 0x470CDD2B, 0x43CDC09C, 0x7B827D21
,0x7F436096, 0x7200464F, 0x76C15BF8, 0x68860BFD, 0x6C47164A
,0x61043093, 0x65C52D24, 0x119B4BE9, 0x155A565E, 0x18197087
,0x1CD86D30, 0x29F3D35, 0x65E2082, 0xB1D065B, 0xFDC1BEC
,0x3793A651, 0x3352BBE6, 0x3E119D3F, 0x3AD08088, 0x2497D08D
,0x2056CD3A, 0x2D15EBE3, 0x29D4F654, 0xC5A92679, 0xC1683BCE
,0xCC2B1D17, 0xC8EA00A0, 0xD6AD50A5, 0xD26C4D12, 0xDF2F6BCB
,0xDBEE767C, 0xE3A1CBC1, 0xE760D676, 0xEA23F0AF, 0xEEE2ED18
,0xF0A5BD1D, 0xF464A0AA, 0xF9278673, 0xFDE69BC4, 0x89B8FD09
,0x8D79E0BE, 0x803AC667, 0x84FBDBD0, 0x9ABC8BD5, 0x9E7D9662
,0x933EB0BB, 0x97FFAD0C, 0xAFB010B1, 0xAB710D06, 0xA6322BDF
,0xA2F33668, 0xBCB4666D, 0xB8757BDA, 0xB5365D03, 0xB1F740B4 };
struct arg_struct {
	user_container *c;
	LocalListener	*l;
};
DWORD dword_30CE28[2122] = {
	//AES_RCON	10
	0x1000000, 0x2000000, 0x4000000, 0x8000000, 0x10000000
	,0x20000000, 0x40000000, 0x80000000, 0x1B000000, 0x36000000

	//AES_E1	256
	,0xC66363A5, 0xF87C7C84, 0xEE777799, 0xF67B7B8D, 0xFFF2F20D
	,0xD66B6BBD, 0xDE6F6FB1, 0x91C5C554, 0x60303050, 0x2010103
	,0xCE6767A9, 0x562B2B7D, 0xE7FEFE19, 0xB5D7D762, 0x4DABABE6
	,0xEC76769A, 0x8FCACA45, 0x1F82829D, 0x89C9C940, 0xFA7D7D87
	,0xEFFAFA15, 0xB25959EB, 0x8E4747C9, 0xFBF0F00B, 0x41ADADEC
	,0xB3D4D467, 0x5FA2A2FD, 0x45AFAFEA, 0x239C9CBF, 0x53A4A4F7
	,0xE4727296, 0x9BC0C05B, 0x75B7B7C2, 0xE1FDFD1C, 0x3D9393AE
	,0x4C26266A, 0x6C36365A, 0x7E3F3F41, 0xF5F7F702, 0x83CCCC4F
	,0x6834345C, 0x51A5A5F4, 0xD1E5E534, 0xF9F1F108, 0xE2717193
	,0xABD8D873, 0x62313153, 0x2A15153F, 0x804040C, 0x95C7C752
	,0x46232365, 0x9DC3C35E, 0x30181828, 0x379696A1, 0xA05050F
	,0x2F9A9AB5, 0xE070709, 0x24121236, 0x1B80809B, 0xDFE2E23D
	,0xCDEBEB26, 0x4E272769, 0x7FB2B2CD, 0xEA75759F, 0x1209091B
	,0x1D83839E, 0x582C2C74, 0x341A1A2E, 0x361B1B2D, 0xDC6E6EB2
	,0xB45A5AEE, 0x5BA0A0FB, 0xA45252F6, 0x763B3B4D, 0xB7D6D661
	,0x7DB3B3CE, 0x5229297B, 0xDDE3E33E, 0x5E2F2F71, 0x13848497
	,0xA65353F5, 0xB9D1D168, 0, 0xC1EDED2C, 0x40202060
	,0xE3FCFC1F, 0x79B1B1C8, 0xB65B5BED, 0xD46A6ABE, 0x8DCBCB46
	,0x67BEBED9, 0x7239394B, 0x944A4ADE, 0x984C4CD4, 0xB05858E8
	,0x85CFCF4A, 0xBBD0D06B, 0xC5EFEF2A, 0x4FAAAAE5, 0xEDFBFB16
	,0x864343C5, 0x9A4D4DD7, 0x66333355, 0x11858594, 0x8A4545CF
	,0xE9F9F910, 0x4020206, 0xFE7F7F81, 0xA05050F0, 0x783C3C44
	,0x259F9FBA, 0x4BA8A8E3, 0xA25151F3, 0x5DA3A3FE, 0x804040C0
	,0x58F8F8A, 0x3F9292AD, 0x219D9DBC, 0x70383848, 0xF1F5F504
	,0x63BCBCDF, 0x77B6B6C1, 0xAFDADA75, 0x42212163, 0x20101030
	,0xE5FFFF1A, 0xFDF3F30E, 0xBFD2D26D, 0x81CDCD4C, 0x180C0C14
	,0x26131335, 0xC3ECEC2F, 0xBE5F5FE1, 0x359797A2, 0x884444CC
	,0x2E171739, 0x93C4C457, 0x55A7A7F2, 0xFC7E7E82, 0x7A3D3D47
	,0xC86464AC, 0xBA5D5DE7, 0x3219192B, 0xE6737395, 0xC06060A0
	,0x19818198, 0x9E4F4FD1, 0xA3DCDC7F, 0x44222266, 0x542A2A7E
	,0x3B9090AB, 0xB888883, 0x8C4646CA, 0xC7EEEE29, 0x6BB8B8D3
	,0x2814143C, 0xA7DEDE79, 0xBC5E5EE2, 0x160B0B1D, 0xADDBDB76
	,0xDBE0E03B, 0x64323256, 0x743A3A4E, 0x140A0A1E, 0x924949DB
	,0xC06060A, 0x4824246C, 0xB85C5CE4, 0x9FC2C25D, 0xBDD3D36E
	,0x43ACACEF, 0xC46262A6, 0x399191A8, 0x319595A4, 0xD3E4E437
	,0xF279798B, 0xD5E7E732, 0x8BC8C843, 0x6E373759, 0xDA6D6DB7
	,0x18D8D8C, 0xB1D5D564, 0x9C4E4ED2, 0x49A9A9E0, 0xD86C6CB4
	,0xAC5656FA, 0xF3F4F407, 0xCFEAEA25, 0xCA6565AF, 0xF47A7A8E
	,0x47AEAEE9, 0x10080818, 0x6FBABAD5, 0xF0787888, 0x4A25256F
	,0x5C2E2E72, 0x381C1C24, 0x57A6A6F1, 0x73B4B4C7, 0x97C6C651
	,0xCBE8E823, 0xA1DDDD7C, 0xE874749C, 0x3E1F1F21, 0x964B4BDD
	,0x61BDBDDC, 0xD8B8B86, 0xF8A8A85, 0xE0707090, 0x7C3E3E42
	,0x71B5B5C4, 0xCC6666AA, 0x904848D8, 0x6030305, 0xF7F6F601
	,0x1C0E0E12, 0xC26161A3, 0x6A35355F, 0xAE5757F9, 0x69B9B9D0
	,0x17868691, 0x99C1C158, 0x3A1D1D27, 0x279E9EB9, 0xD9E1E138
	,0xEBF8F813, 0x2B9898B3, 0x22111133, 0xD26969BB, 0xA9D9D970
	,0x78E8E89, 0x339494A7, 0x2D9B9BB6, 0x3C1E1E22, 0x15878792
	,0xC9E9E920, 0x87CECE49, 0xAA5555FF, 0x50282878, 0xA5DFDF7A
	,0x38C8C8F, 0x59A1A1F8, 0x9898980, 0x1A0D0D17, 0x65BFBFDA
	,0xD7E6E631, 0x844242C6, 0xD06868B8, 0x824141C3, 0x299999B0
	,0x5A2D2D77, 0x1E0F0F11, 0x7BB0B0CB, 0xA85454FC, 0x6DBBBBD6
	,0x2C16163A,
	//AES_E2		256
	0xA5C66363, 0x84F87C7C, 0x99EE7777, 0x8DF67B7B
	,0xDFFF2F2, 0xBDD66B6B, 0xB1DE6F6F, 0x5491C5C5, 0x50603030
	,0x3020101, 0xA9CE6767, 0x7D562B2B, 0x19E7FEFE, 0x62B5D7D7
	,0xE64DABAB, 0x9AEC7676, 0x458FCACA, 0x9D1F8282, 0x4089C9C9
	,0x87FA7D7D, 0x15EFFAFA, 0xEBB25959, 0xC98E4747, 0xBFBF0F0
	,0xEC41ADAD, 0x67B3D4D4, 0xFD5FA2A2, 0xEA45AFAF, 0xBF239C9C
	,0xF753A4A4, 0x96E47272, 0x5B9BC0C0, 0xC275B7B7, 0x1CE1FDFD
	,0xAE3D9393, 0x6A4C2626, 0x5A6C3636, 0x417E3F3F, 0x2F5F7F7
	,0x4F83CCCC, 0x5C683434, 0xF451A5A5, 0x34D1E5E5, 0x8F9F1F1
	,0x93E27171, 0x73ABD8D8, 0x53623131, 0x3F2A1515, 0xC080404
	,0x5295C7C7, 0x65462323, 0x5E9DC3C3, 0x28301818, 0xA1379696
	,0xF0A0505, 0xB52F9A9A, 0x90E0707, 0x36241212, 0x9B1B8080
	,0x3DDFE2E2, 0x26CDEBEB, 0x694E2727, 0xCD7FB2B2, 0x9FEA7575
	,0x1B120909, 0x9E1D8383, 0x74582C2C, 0x2E341A1A, 0x2D361B1B
	,0xB2DC6E6E, 0xEEB45A5A, 0xFB5BA0A0, 0xF6A45252, 0x4D763B3B
	,0x61B7D6D6, 0xCE7DB3B3, 0x7B522929, 0x3EDDE3E3, 0x715E2F2F
	,0x97138484, 0xF5A65353, 0x68B9D1D1, 0, 0x2CC1EDED
	,0x60402020, 0x1FE3FCFC, 0xC879B1B1, 0xEDB65B5B, 0xBED46A6A
	,0x468DCBCB, 0xD967BEBE, 0x4B723939, 0xDE944A4A, 0xD4984C4C
	,0xE8B05858, 0x4A85CFCF, 0x6BBBD0D0, 0x2AC5EFEF, 0xE54FAAAA
	,0x16EDFBFB, 0xC5864343, 0xD79A4D4D, 0x55663333, 0x94118585
	,0xCF8A4545, 0x10E9F9F9, 0x6040202, 0x81FE7F7F, 0xF0A05050
	,0x44783C3C, 0xBA259F9F, 0xE34BA8A8, 0xF3A25151, 0xFE5DA3A3
	,0xC0804040, 0x8A058F8F, 0xAD3F9292, 0xBC219D9D, 0x48703838
	,0x4F1F5F5, 0xDF63BCBC, 0xC177B6B6, 0x75AFDADA, 0x63422121
	,0x30201010, 0x1AE5FFFF, 0xEFDF3F3, 0x6DBFD2D2, 0x4C81CDCD
	,0x14180C0C, 0x35261313, 0x2FC3ECEC, 0xE1BE5F5F, 0xA2359797
	,0xCC884444, 0x392E1717, 0x5793C4C4, 0xF255A7A7, 0x82FC7E7E
	,0x477A3D3D, 0xACC86464, 0xE7BA5D5D, 0x2B321919, 0x95E67373
	,0xA0C06060, 0x98198181, 0xD19E4F4F, 0x7FA3DCDC, 0x66442222
	,0x7E542A2A, 0xAB3B9090, 0x830B8888, 0xCA8C4646, 0x29C7EEEE
	,0xD36BB8B8, 0x3C281414, 0x79A7DEDE, 0xE2BC5E5E, 0x1D160B0B
	,0x76ADDBDB, 0x3BDBE0E0, 0x56643232, 0x4E743A3A, 0x1E140A0A
	,0xDB924949, 0xA0C0606, 0x6C482424, 0xE4B85C5C, 0x5D9FC2C2
	,0x6EBDD3D3, 0xEF43ACAC, 0xA6C46262, 0xA8399191, 0xA4319595
	,0x37D3E4E4, 0x8BF27979, 0x32D5E7E7, 0x438BC8C8, 0x596E3737
	,0xB7DA6D6D, 0x8C018D8D, 0x64B1D5D5, 0xD29C4E4E, 0xE049A9A9
	,0xB4D86C6C, 0xFAAC5656, 0x7F3F4F4, 0x25CFEAEA, 0xAFCA6565
	,0x8EF47A7A, 0xE947AEAE, 0x18100808, 0xD56FBABA, 0x88F07878
	,0x6F4A2525, 0x725C2E2E, 0x24381C1C, 0xF157A6A6, 0xC773B4B4
	,0x5197C6C6, 0x23CBE8E8, 0x7CA1DDDD, 0x9CE87474, 0x213E1F1F
	,0xDD964B4B, 0xDC61BDBD, 0x860D8B8B, 0x850F8A8A, 0x90E07070
	,0x427C3E3E, 0xC471B5B5, 0xAACC6666, 0xD8904848, 0x5060303
	,0x1F7F6F6, 0x121C0E0E, 0xA3C26161, 0x5F6A3535, 0xF9AE5757
	,0xD069B9B9, 0x91178686, 0x5899C1C1, 0x273A1D1D, 0xB9279E9E
	,0x38D9E1E1, 0x13EBF8F8, 0xB32B9898, 0x33221111, 0xBBD26969
	,0x70A9D9D9, 0x89078E8E, 0xA7339494, 0xB62D9B9B, 0x223C1E1E
	,0x92158787, 0x20C9E9E9, 0x4987CECE, 0xFFAA5555, 0x78502828
	,0x7AA5DFDF, 0x8F038C8C, 0xF859A1A1, 0x80098989, 0x171A0D0D
	,0xDA65BFBF, 0x31D7E6E6, 0xC6844242, 0xB8D06868, 0xC3824141
	,0xB0299999, 0x775A2D2D, 0x111E0F0F, 0xCB7BB0B0, 0xFCA85454
	,0xD66DBBBB, 0x3A2C1616,

	//AES_E3	256
	0x63A5C663, 0x7C84F87C, 0x7799EE77
	,0x7B8DF67B, 0xF20DFFF2, 0x6BBDD66B, 0x6FB1DE6F, 0xC55491C5
	,0x30506030, 0x1030201, 0x67A9CE67, 0x2B7D562B, 0xFE19E7FE
	,0xD762B5D7, 0xABE64DAB, 0x769AEC76, 0xCA458FCA, 0x829D1F82
	,0xC94089C9, 0x7D87FA7D, 0xFA15EFFA, 0x59EBB259, 0x47C98E47
	,0xF00BFBF0, 0xADEC41AD, 0xD467B3D4, 0xA2FD5FA2, 0xAFEA45AF
	,0x9CBF239C, 0xA4F753A4, 0x7296E472, 0xC05B9BC0, 0xB7C275B7
	,0xFD1CE1FD, 0x93AE3D93, 0x266A4C26, 0x365A6C36, 0x3F417E3F
	,0xF702F5F7, 0xCC4F83CC, 0x345C6834, 0xA5F451A5, 0xE534D1E5
	,0xF108F9F1, 0x7193E271, 0xD873ABD8, 0x31536231, 0x153F2A15
	,0x40C0804, 0xC75295C7, 0x23654623, 0xC35E9DC3, 0x18283018
	,0x96A13796, 0x50F0A05, 0x9AB52F9A, 0x7090E07, 0x12362412
	,0x809B1B80, 0xE23DDFE2, 0xEB26CDEB, 0x27694E27, 0xB2CD7FB2
	,0x759FEA75, 0x91B1209, 0x839E1D83, 0x2C74582C, 0x1A2E341A
	,0x1B2D361B, 0x6EB2DC6E, 0x5AEEB45A, 0xA0FB5BA0, 0x52F6A452
	,0x3B4D763B, 0xD661B7D6, 0xB3CE7DB3, 0x297B5229, 0xE33EDDE3
	,0x2F715E2F, 0x84971384, 0x53F5A653, 0xD168B9D1, 0
	,0xED2CC1ED, 0x20604020, 0xFC1FE3FC, 0xB1C879B1, 0x5BEDB65B
	,0x6ABED46A, 0xCB468DCB, 0xBED967BE, 0x394B7239, 0x4ADE944A
	,0x4CD4984C, 0x58E8B058, 0xCF4A85CF, 0xD06BBBD0, 0xEF2AC5EF
	,0xAAE54FAA, 0xFB16EDFB, 0x43C58643, 0x4DD79A4D, 0x33556633
	,0x85941185, 0x45CF8A45, 0xF910E9F9, 0x2060402, 0x7F81FE7F
	,0x50F0A050, 0x3C44783C, 0x9FBA259F, 0xA8E34BA8, 0x51F3A251
	,0xA3FE5DA3, 0x40C08040, 0x8F8A058F, 0x92AD3F92, 0x9DBC219D
	,0x38487038, 0xF504F1F5, 0xBCDF63BC, 0xB6C177B6, 0xDA75AFDA
	,0x21634221, 0x10302010, 0xFF1AE5FF, 0xF30EFDF3, 0xD26DBFD2
	,0xCD4C81CD, 0xC14180C, 0x13352613, 0xEC2FC3EC, 0x5FE1BE5F
	,0x97A23597, 0x44CC8844, 0x17392E17, 0xC45793C4, 0xA7F255A7
	,0x7E82FC7E, 0x3D477A3D, 0x64ACC864, 0x5DE7BA5D, 0x192B3219
	,0x7395E673, 0x60A0C060, 0x81981981, 0x4FD19E4F, 0xDC7FA3DC
	,0x22664422, 0x2A7E542A, 0x90AB3B90, 0x88830B88, 0x46CA8C46
	,0xEE29C7EE, 0xB8D36BB8, 0x143C2814, 0xDE79A7DE, 0x5EE2BC5E
	,0xB1D160B, 0xDB76ADDB, 0xE03BDBE0, 0x32566432, 0x3A4E743A
	,0xA1E140A, 0x49DB9249, 0x60A0C06, 0x246C4824, 0x5CE4B85C
	,0xC25D9FC2, 0xD36EBDD3, 0xACEF43AC, 0x62A6C462, 0x91A83991
	,0x95A43195, 0xE437D3E4, 0x798BF279, 0xE732D5E7, 0xC8438BC8
	,0x37596E37, 0x6DB7DA6D, 0x8D8C018D, 0xD564B1D5, 0x4ED29C4E
	,0xA9E049A9, 0x6CB4D86C, 0x56FAAC56, 0xF407F3F4, 0xEA25CFEA
	,0x65AFCA65, 0x7A8EF47A, 0xAEE947AE, 0x8181008, 0xBAD56FBA
	,0x7888F078, 0x256F4A25, 0x2E725C2E, 0x1C24381C, 0xA6F157A6
	,0xB4C773B4, 0xC65197C6, 0xE823CBE8, 0xDD7CA1DD, 0x749CE874
	,0x1F213E1F, 0x4BDD964B, 0xBDDC61BD, 0x8B860D8B, 0x8A850F8A
	,0x7090E070, 0x3E427C3E, 0xB5C471B5, 0x66AACC66, 0x48D89048
	,0x3050603, 0xF601F7F6, 0xE121C0E, 0x61A3C261, 0x355F6A35
	,0x57F9AE57, 0xB9D069B9, 0x86911786, 0xC15899C1, 0x1D273A1D
	,0x9EB9279E, 0xE138D9E1, 0xF813EBF8, 0x98B32B98, 0x11332211
	,0x69BBD269, 0xD970A9D9, 0x8E89078E, 0x94A73394, 0x9BB62D9B
	,0x1E223C1E, 0x87921587, 0xE920C9E9, 0xCE4987CE, 0x55FFAA55
	,0x28785028, 0xDF7AA5DF, 0x8C8F038C, 0xA1F859A1, 0x89800989
	,0xD171A0D, 0xBFDA65BF, 0xE631D7E6, 0x42C68442, 0x68B8D068
	,0x41C38241, 0x99B02999, 0x2D775A2D, 0xF111E0F, 0xB0CB7BB0
	,0x54FCA854, 0xBBD66DBB, 0x163A2C16,

	//AES_E4	256
	0x6363A5C6, 0x7C7C84F8
	,0x777799EE, 0x7B7B8DF6, 0xF2F20DFF, 0x6B6BBDD6, 0x6F6FB1DE
	,0xC5C55491, 0x30305060, 0x1010302, 0x6767A9CE, 0x2B2B7D56
	,0xFEFE19E7, 0xD7D762B5, 0xABABE64D, 0x76769AEC, 0xCACA458F
	,0x82829D1F, 0xC9C94089, 0x7D7D87FA, 0xFAFA15EF, 0x5959EBB2
	,0x4747C98E, 0xF0F00BFB, 0xADADEC41, 0xD4D467B3, 0xA2A2FD5F
	,0xAFAFEA45, 0x9C9CBF23, 0xA4A4F753, 0x727296E4, 0xC0C05B9B
	,0xB7B7C275, 0xFDFD1CE1, 0x9393AE3D, 0x26266A4C, 0x36365A6C
	,0x3F3F417E, 0xF7F702F5, 0xCCCC4F83, 0x34345C68, 0xA5A5F451
	,0xE5E534D1, 0xF1F108F9, 0x717193E2, 0xD8D873AB, 0x31315362
	,0x15153F2A, 0x4040C08, 0xC7C75295, 0x23236546, 0xC3C35E9D
	,0x18182830, 0x9696A137, 0x5050F0A, 0x9A9AB52F, 0x707090E
	,0x12123624, 0x80809B1B, 0xE2E23DDF, 0xEBEB26CD, 0x2727694E
	,0xB2B2CD7F, 0x75759FEA, 0x9091B12, 0x83839E1D, 0x2C2C7458
	,0x1A1A2E34, 0x1B1B2D36, 0x6E6EB2DC, 0x5A5AEEB4, 0xA0A0FB5B
	,0x5252F6A4, 0x3B3B4D76, 0xD6D661B7, 0xB3B3CE7D, 0x29297B52
	,0xE3E33EDD, 0x2F2F715E, 0x84849713, 0x5353F5A6, 0xD1D168B9
	,0, 0xEDED2CC1, 0x20206040, 0xFCFC1FE3, 0xB1B1C879
	,0x5B5BEDB6, 0x6A6ABED4, 0xCBCB468D, 0xBEBED967, 0x39394B72
	,0x4A4ADE94, 0x4C4CD498, 0x5858E8B0, 0xCFCF4A85, 0xD0D06BBB
	,0xEFEF2AC5, 0xAAAAE54F, 0xFBFB16ED, 0x4343C586, 0x4D4DD79A
	,0x33335566, 0x85859411, 0x4545CF8A, 0xF9F910E9, 0x2020604
	,0x7F7F81FE, 0x5050F0A0, 0x3C3C4478, 0x9F9FBA25, 0xA8A8E34B
	,0x5151F3A2, 0xA3A3FE5D, 0x4040C080, 0x8F8F8A05, 0x9292AD3F
	,0x9D9DBC21, 0x38384870, 0xF5F504F1, 0xBCBCDF63, 0xB6B6C177
	,0xDADA75AF, 0x21216342, 0x10103020, 0xFFFF1AE5, 0xF3F30EFD
	,0xD2D26DBF, 0xCDCD4C81, 0xC0C1418, 0x13133526, 0xECEC2FC3
	,0x5F5FE1BE, 0x9797A235, 0x4444CC88, 0x1717392E, 0xC4C45793
	,0xA7A7F255, 0x7E7E82FC, 0x3D3D477A, 0x6464ACC8, 0x5D5DE7BA
	,0x19192B32, 0x737395E6, 0x6060A0C0, 0x81819819, 0x4F4FD19E
	,0xDCDC7FA3, 0x22226644, 0x2A2A7E54, 0x9090AB3B, 0x8888830B
	,0x4646CA8C, 0xEEEE29C7, 0xB8B8D36B, 0x14143C28, 0xDEDE79A7
	,0x5E5EE2BC, 0xB0B1D16, 0xDBDB76AD, 0xE0E03BDB, 0x32325664
	,0x3A3A4E74, 0xA0A1E14, 0x4949DB92, 0x6060A0C, 0x24246C48
	,0x5C5CE4B8, 0xC2C25D9F, 0xD3D36EBD, 0xACACEF43, 0x6262A6C4
	,0x9191A839, 0x9595A431, 0xE4E437D3, 0x79798BF2, 0xE7E732D5
	,0xC8C8438B, 0x3737596E, 0x6D6DB7DA, 0x8D8D8C01, 0xD5D564B1
	,0x4E4ED29C, 0xA9A9E049, 0x6C6CB4D8, 0x5656FAAC, 0xF4F407F3
	,0xEAEA25CF, 0x6565AFCA, 0x7A7A8EF4, 0xAEAEE947, 0x8081810
	,0xBABAD56F, 0x787888F0, 0x25256F4A, 0x2E2E725C, 0x1C1C2438
	,0xA6A6F157, 0xB4B4C773, 0xC6C65197, 0xE8E823CB, 0xDDDD7CA1
	,0x74749CE8, 0x1F1F213E, 0x4B4BDD96, 0xBDBDDC61, 0x8B8B860D
	,0x8A8A850F, 0x707090E0, 0x3E3E427C, 0xB5B5C471, 0x6666AACC
	,0x4848D890, 0x3030506, 0xF6F601F7, 0xE0E121C, 0x6161A3C2
	,0x35355F6A, 0x5757F9AE, 0xB9B9D069, 0x86869117, 0xC1C15899
	,0x1D1D273A, 0x9E9EB927, 0xE1E138D9, 0xF8F813EB, 0x9898B32B
	,0x11113322, 0x6969BBD2, 0xD9D970A9, 0x8E8E8907, 0x9494A733
	,0x9B9BB62D, 0x1E1E223C, 0x87879215, 0xE9E920C9, 0xCECE4987
	,0x5555FFAA, 0x28287850, 0xDFDF7AA5, 0x8C8C8F03, 0xA1A1F859
	,0x89898009, 0xD0D171A, 0xBFBFDA65, 0xE6E631D7, 0x4242C684
	,0x6868B8D0, 0x4141C382, 0x9999B029, 0x2D2D775A, 0xF0F111E
	,0xB0B0CB7B, 0x5454FCA8, 0xBBBBD66D, 0x16163A2C,



	//static const uint32_t U3[256] = {
	0xF4A75051
	,0x4165537E, 0x17A4C31A, 0x275E963A, 0xAB6BCB3B, 0x9D45F11F
	,0xFA58ABAC, 0xE303934B, 0x30FA5520, 0x766DF6AD, 0xCC769188
	,0x24C25F5, 0xE5D7FC4F, 0x2ACBD7C5, 0x35448026, 0x62A38FB5
	,0xB15A49DE, 0xBA1B6725, 0xEA0E9845, 0xFEC0E15D, 0x2F7502C3
	,0x4CF01281, 0x4697A38D, 0xD3F9C66B, 0x8F5FE703, 0x929C9515
	,0x6D7AEBBF, 0x5259DA95, 0xBE832DD4, 0x7421D358, 0xE0692949
	,0xC9C8448E, 0xC2896A75, 0x8E7978F4, 0x583E6B99, 0xB971DD27
	,0xE14FB6BE, 0x88AD17F0, 0x20AC66C9, 0xCE3AB47D, 0xDF4A1863
	,0x1A3182E5, 0x51336097, 0x537F4562, 0x6477E0B1, 0x6BAE84BB
	,0x81A01CFE, 0x82B94F9, 0x48685870, 0x45FD198F, 0xDE6C8794
	,0x7BF8B752,0x73D323AB, 0x4B02E272, 0x1F8F57E3, 0x55AB2A66, 0xEB2807B2
	,0xB5C2032F, 0xC57B9A86, 0x3708A5D3, 0x2887F230, 0xBFA5B223
	,0x36ABA02, 0x16825CED, 0xCF1C2B8A, 0x79B492A7, 0x7F2F0F3
	,0x69E2A14E, 0xDAF4CD65, 0x5BED506, 0x34621FD1, 0xA6FE8AC4
	,0x2E539D34, 0xF355A0A2, 0x8AE13205, 0xF6EB75A4, 0x83EC390B
	,0x60EFAA40, 0x719F065E, 0x6E1051BD, 0x218AF93E, 0xDD063D96
	,0x3E05AEDD, 0xE6BD464D, 0x548DB591, 0xC45D0571, 0x6D46F04
	,0x5015FF60, 0x98FB2419, 0xBDE997D6, 0x4043CC89, 0xD99E7767
	,0xE842BDB0, 0x898B8807, 0x195B38E7, 0xC8EEDB79, 0x7C0A47A1
	,0x420FE97C, 0x841EC9F8, 0, 0x80868309, 0x2BED4832
	,0x1170AC1E, 0x5A724E6C, 0xEFFFBFD, 0x8538560F, 0xAED51E3D
	,0x2D392736, 0xFD9640A, 0x5CA62168, 0x5B54D19B, 0x362E3A24
	,0xA67B10C, 0x57E70F93, 0xEE96D2B4, 0x9B919E1B, 0xC0C54F80
	,0xDC20A261, 0x774B695A, 0x121A161C, 0x93BA0AE2, 0xA02AE5C0
	,0x22E0433C, 0x1B171D12, 0x90D0B0E, 0x8BC7ADF2, 0xB6A8B92D
	,0x1EA9C814, 0xF1198557, 0x75074CAF, 0x99DDBBEE, 0x7F60FDA3
	,0x1269FF7, 0x72F5BC5C, 0x663BC544, 0xFB7E345B, 0x4329768B
	,0x23C6DCCB, 0xEDFC68B6, 0xE4F163B8, 0x31DCCAD7, 0x63851042
	,0x97224013, 0xC6112084, 0x4A247D85, 0xBB3DF8D2, 0xF93211AE
	,0x29A16DC7, 0x9E2F4B1D, 0xB230F3DC, 0x8652EC0D, 0xC1E3D077
	,0xB3166C2B, 0x70B999A9, 0x9448FA11, 0xE9642247, 0xFC8CC4A8
	,0xF03F1AA0, 0x7D2CD856, 0x3390EF22, 0x494EC787, 0x38D1C1D9
	,0xCAA2FE8C, 0xD40B3698, 0xF581CFA6, 0x7ADE28A5, 0xB78E26DA
	,0xADBFA43F, 0x3A9DE42C, 0x78920D50, 0x5FCC9B6A, 0x7E466254
	,0x8D13C2F6, 0xD8B8E890, 0x39F75E2E, 0xC3AFF582, 0x5D80BE9F
	,0xD0937C69, 0xD52DA96F, 0x2512B3CF, 0xAC993BC8, 0x187DA710
	,0x9C636EE8, 0x3BBB7BDB, 0x267809CD, 0x5918F46E, 0x9AB701EC
	,0x4F9AA883, 0x956E65E6, 0xFFE67EAA, 0xBCCF0821, 0x15E8E6EF
	,0xE79BD9BA, 0x6F36CE4A, 0x9F09D4EA, 0xB07CD629, 0xA4B2AF31
	,0x3F23312A, 0xA59430C6, 0xA266C035, 0x4EBC3774, 0x82CAA6FC
	,0x90D0B0E0, 0xA7D81533, 0x4984AF1, 0xECDAF741, 0xCD500E7F
	,0x91F62F17, 0x4DD68D76, 0xEFB04D43, 0xAA4D54CC, 0x9604DFE4
	,0xD1B5E39E, 0x6A881B4C, 0x2C1FB8C1, 0x65517F46, 0x5EEA049D
	,0x8C355D01, 0x877473FA, 0xB412EFB, 0x671D5AB3, 0xDBD25292
	,0x105633E9, 0xD647136D, 0xD7618C9A, 0xA10C7A37, 0xF8148E59
	,0x133C89EB, 0xA927EECE, 0x61C935B7, 0x1CE5EDE1, 0x47B13C7A
	,0xD2DF599C, 0xF2733F55, 0x14CE7918, 0xC737BF73, 0xF7CDEA53
	,0xFDAA5B5F, 0x3D6F14DF, 0x44DB8678, 0xAFF381CA, 0x68C43EB9
	,0x24342C38, 0xA3405FC2, 0x1DC37216, 0xE2250CBC, 0x3C498B28
	,0xD9541FF, 0xA8017139, 0xCB3DE08, 0xB4E49CD8, 0x56C19064
	,0xCB84617B, 0x32B670D5, 0x6C5C7448, 0xB85742D0,


	//static const uint32_t U0[256] = {

	0x51F4A750
	,0x7E416553, 0x1A17A4C3, 0x3A275E96, 0x3BAB6BCB, 0x1F9D45F1
	,0xACFA58AB, 0x4BE30393, 0x2030FA55, 0xAD766DF6, 0x88CC7691
	,0xF5024C25, 0x4FE5D7FC, 0xC52ACBD7, 0x26354480, 0xB562A38F
	,0xDEB15A49, 0x25BA1B67, 0x45EA0E98, 0x5DFEC0E1, 0xC32F7502
	,0x814CF012, 0x8D4697A3, 0x6BD3F9C6, 0x38F5FE7, 0x15929C95
	,0xBF6D7AEB, 0x955259DA, 0xD4BE832D, 0x587421D3, 0x49E06929
	,0x8EC9C844, 0x75C2896A, 0xF48E7978, 0x99583E6B, 0x27B971DD
	,0xBEE14FB6, 0xF088AD17, 0xC920AC66, 0x7DCE3AB4, 0x63DF4A18
	,0xE51A3182, 0x97513360, 0x62537F45, 0xB16477E0, 0xBB6BAE84
	,0xFE81A01C, 0xF9082B94, 0x70486858, 0x8F45FD19, 0x94DE6C87
	,0x527BF8B7, 0xAB73D323, 0x724B02E2, 0xE31F8F57, 0x6655AB2A
	,0xB2EB2807, 0x2FB5C203, 0x86C57B9A, 0xD33708A5, 0x302887F2
	,0x23BFA5B2, 0x2036ABA, 0xED16825C, 0x8ACF1C2B, 0xA779B492
	,0xF307F2F0, 0x4E69E2A1, 0x65DAF4CD, 0x605BED5, 0xD134621F
	,0xC4A6FE8A, 0x342E539D, 0xA2F355A0, 0x58AE132, 0xA4F6EB75
	,0xB83EC39, 0x4060EFAA, 0x5E719F06, 0xBD6E1051, 0x3E218AF9
	,0x96DD063D, 0xDD3E05AE, 0x4DE6BD46, 0x91548DB5, 0x71C45D05
	,0x406D46F, 0x605015FF, 0x1998FB24, 0xD6BDE997, 0x894043CC
	,0x67D99E77, 0xB0E842BD, 0x7898B88, 0xE7195B38, 0x79C8EEDB
	,0xA17C0A47, 0x7C420FE9, 0xF8841EC9, 0, 0x9808683, 0x322BED48
	,0x1E1170AC, 0x6C5A724E, 0xFD0EFFFB, 0xF853856, 0x3DAED51E
	,0x362D3927, 0xA0FD964, 0x685CA621, 0x9B5B54D1, 0x24362E3A
	,0xC0A67B1, 0x9357E70F, 0xB4EE96D2, 0x1B9B919E, 0x80C0C54F
	,0x61DC20A2, 0x5A774B69, 0x1C121A16, 0xE293BA0A, 0xC0A02AE5
	,0x3C22E043, 0x121B171D, 0xE090D0B, 0xF28BC7AD, 0x2DB6A8B9
	,0x141EA9C8, 0x57F11985, 0xAF75074C, 0xEE99DDBB, 0xA37F60FD
	,0xF701269F, 0x5C72F5BC, 0x44663BC5, 0x5BFB7E34, 0x8B432976
	,0xCB23C6DC, 0xB6EDFC68, 0xB8E4F163, 0xD731DCCA, 0x42638510
	,0x13972240, 0x84C61120, 0x854A247D, 0xD2BB3DF8, 0xAEF93211
	,0xC729A16D, 0x1D9E2F4B, 0xDCB230F3, 0xD8652EC, 0x77C1E3D0
	,0x2BB3166C, 0xA970B999, 0x119448FA, 0x47E96422, 0xA8FC8CC4
	,0xA0F03F1A, 0x567D2CD8, 0x223390EF, 0x87494EC7, 0xD938D1C1
	,0x8CCAA2FE, 0x98D40B36, 0xA6F581CF, 0xA57ADE28, 0xDAB78E26
	,0x3FADBFA4, 0x2C3A9DE4, 0x5078920D, 0x6A5FCC9B, 0x547E4662
	,0xF68D13C2, 0x90D8B8E8, 0x2E39F75E, 0x82C3AFF5, 0x9F5D80BE
	,0x69D0937C, 0x6FD52DA9, 0xCF2512B3, 0xC8AC993B, 0x10187DA7
	,0xE89C636E, 0xDB3BBB7B, 0xCD267809, 0x6E5918F4, 0xEC9AB701
	,0x834F9AA8, 0xE6956E65, 0xAAFFE67E, 0x21BCCF08, 0xEF15E8E6
	,0xBAE79BD9, 0x4A6F36CE, 0xEA9F09D4, 0x29B07CD6, 0x31A4B2AF
	,0x2A3F2331, 0xC6A59430, 0x35A266C0, 0x744EBC37, 0xFC82CAA6
	,0xE090D0B0, 0x33A7D815, 0xF104984A, 0x41ECDAF7, 0x7FCD500E
	,0x1791F62F, 0x764DD68D, 0x43EFB04D, 0xCCAA4D54, 0xE49604DF
	,0x9ED1B5E3, 0x4C6A881B, 0xC12C1FB8, 0x4665517F, 0x9D5EEA04
	,0x18C355D, 0xFA877473, 0xFB0B412E, 0xB3671D5A, 0x92DBD252
	,0xE9105633, 0x6DD64713, 0x9AD7618C, 0x37A10C7A, 0x59F8148E
	,0xEB133C89, 0xCEA927EE, 0xB761C935, 0xE11CE5ED, 0x7A47B13C
	,0x9CD2DF59, 0x55F2733F, 0x1814CE79, 0x73C737BF, 0x53F7CDEA
	,0x5FFDAA5B, 0xDF3D6F14, 0x7844DB86, 0xCAAFF381, 0xB968C43E
	,0x3824342C, 0xC2A3405F, 0x161DC372, 0xBCE2250C, 0x283C498B
	,0xFF0D9541, 0x39A80171, 0x80CB3DE, 0xD8B4E49C, 0x6456C190
	,0x7BCB8461, 0xD532B670, 0x486C5C74, 0xD0B85742,


	//static const uint32_t U1[256] = {

	0x5051F4A7
	,0x537E4165, 0xC31A17A4, 0x963A275E, 0xCB3BAB6B, 0xF11F9D45
	,0xABACFA58, 0x934BE303, 0x552030FA, 0xF6AD766D, 0x9188CC76
	,0x25F5024C, 0xFC4FE5D7, 0xD7C52ACB, 0x80263544, 0x8FB562A3
	,0x49DEB15A, 0x6725BA1B, 0x9845EA0E, 0xE15DFEC0, 0x2C32F75
	,0x12814CF0, 0xA38D4697, 0xC66BD3F9, 0xE7038F5F, 0x9515929C
	,0xEBBF6D7A, 0xDA955259, 0x2DD4BE83, 0xD3587421, 0x2949E069
	,0x448EC9C8, 0x6A75C289, 0x78F48E79, 0x6B99583E, 0xDD27B971
	,0xB6BEE14F, 0x17F088AD, 0x66C920AC, 0xB47DCE3A, 0x1863DF4A
	,0x82E51A31, 0x60975133, 0x4562537F, 0xE0B16477, 0x84BB6BAE
	,0x1CFE81A0, 0x94F9082B, 0x58704868, 0x198F45FD, 0x8794DE6C
	,0xB7527BF8, 0x23AB73D3, 0xE2724B02, 0x57E31F8F, 0x2A6655AB
	,0x7B2EB28, 0x32FB5C2, 0x9A86C57B, 0xA5D33708, 0xF2302887
	,0xB223BFA5, 0xBA02036A, 0x5CED1682, 0x2B8ACF1C, 0x92A779B4
	,0xF0F307F2, 0xA14E69E2, 0xCD65DAF4, 0xD50605BE, 0x1FD13462
	,0x8AC4A6FE, 0x9D342E53, 0xA0A2F355, 0x32058AE1, 0x75A4F6EB
	,0x390B83EC, 0xAA4060EF, 0x65E719F, 0x51BD6E10, 0xF93E218A
	,0x3D96DD06, 0xAEDD3E05, 0x464DE6BD, 0xB591548D, 0x571C45D
	,0x6F0406D4, 0xFF605015, 0x241998FB, 0x97D6BDE9, 0xCC894043
	,0x7767D99E, 0xBDB0E842, 0x8807898B, 0x38E7195B, 0xDB79C8EE
	,0x47A17C0A, 0xE97C420F, 0xC9F8841E, 0, 0x83098086
	,0x48322BED, 0xAC1E1170, 0x4E6C5A72, 0xFBFD0EFF, 0x560F8538
	,0x1E3DAED5, 0x27362D39, 0x640A0FD9, 0x21685CA6, 0xD19B5B54
	,0x3A24362E, 0xB10C0A67, 0xF9357E7, 0xD2B4EE96, 0x9E1B9B91
	,0x4F80C0C5, 0xA261DC20, 0x695A774B, 0x161C121A, 0xAE293BA
	,0xE5C0A02A, 0x433C22E0, 0x1D121B17, 0xB0E090D, 0xADF28BC7
	,0xB92DB6A8, 0xC8141EA9, 0x8557F119, 0x4CAF7507, 0xBBEE99DD
	,0xFDA37F60, 0x9FF70126, 0xBC5C72F5, 0xC544663B, 0x345BFB7E
	,0x768B4329, 0xDCCB23C6, 0x68B6EDFC, 0x63B8E4F1, 0xCAD731DC
	,0x10426385, 0x40139722, 0x2084C611, 0x7D854A24, 0xF8D2BB3D
	,0x11AEF932, 0x6DC729A1, 0x4B1D9E2F, 0xF3DCB230, 0xEC0D8652
	,0xD077C1E3, 0x6C2BB316, 0x99A970B9, 0xFA119448, 0x2247E964
	,0xC4A8FC8C, 0x1AA0F03F, 0xD8567D2C, 0xEF223390, 0xC787494E
	,0xC1D938D1, 0xFE8CCAA2, 0x3698D40B, 0xCFA6F581, 0x28A57ADE
	,0x26DAB78E, 0xA43FADBF, 0xE42C3A9D, 0xD507892, 0x9B6A5FCC
	,0x62547E46, 0xC2F68D13, 0xE890D8B8, 0x5E2E39F7, 0xF582C3AF
	,0xBE9F5D80, 0x7C69D093, 0xA96FD52D, 0xB3CF2512, 0x3BC8AC99
	,0xA710187D, 0x6EE89C63, 0x7BDB3BBB, 0x9CD2678, 0xF46E5918
	,0x1EC9AB7, 0xA8834F9A, 0x65E6956E, 0x7EAAFFE6, 0x821BCCF
	,0xE6EF15E8, 0xD9BAE79B, 0xCE4A6F36, 0xD4EA9F09, 0xD629B07C
	,0xAF31A4B2, 0x312A3F23, 0x30C6A594, 0xC035A266, 0x37744EBC
	,0xA6FC82CA, 0xB0E090D0, 0x1533A7D8, 0x4AF10498, 0xF741ECDA
	,0xE7FCD50, 0x2F1791F6, 0x8D764DD6, 0x4D43EFB0, 0x54CCAA4D
	,0xDFE49604, 0xE39ED1B5, 0x1B4C6A88, 0xB8C12C1F, 0x7F466551
	,0x49D5EEA, 0x5D018C35, 0x73FA8774, 0x2EFB0B41, 0x5AB3671D
	,0x5292DBD2, 0x33E91056, 0x136DD647, 0x8C9AD761, 0x7A37A10C
	,0x8E59F814, 0x89EB133C, 0xEECEA927, 0x35B761C9, 0xEDE11CE5
	,0x3C7A47B1, 0x599CD2DF, 0x3F55F273, 0x791814CE, 0xBF73C737
	,0xEA53F7CD, 0x5B5FFDAA, 0x14DF3D6F, 0x867844DB, 0x81CAAFF3
	,0x3EB968C4, 0x2C382434, 0x5FC2A340, 0x72161DC3, 0xCBCE225
	,0x8B283C49, 0x41FF0D95, 0x7139A801, 0xDE080CB3, 0x9CD8B4E4
	,0x906456C1, 0x617BCB84, 0x70D532B6, 0x74486C5C, 0x42D0B857

	//static const uint32_t U2[256] = {

	,0xA75051F4, 0x65537E41, 0xA4C31A17, 0x5E963A27, 0x6BCB3BAB
	,0x45F11F9D, 0x58ABACFA, 0x3934BE3, 0xFA552030, 0x6DF6AD76
	,0x769188CC, 0x4C25F502, 0xD7FC4FE5, 0xCBD7C52A, 0x44802635
	,0xA38FB562, 0x5A49DEB1, 0x1B6725BA, 0xE9845EA, 0xC0E15DFE
	,0x7502C32F, 0xF012814C, 0x97A38D46, 0xF9C66BD3, 0x5FE7038F
	,0x9C951592, 0x7AEBBF6D, 0x59DA9552, 0x832DD4BE, 0x21D35874
	,0x692949E0, 0xC8448EC9, 0x896A75C2, 0x7978F48E, 0x3E6B9958
	,0x71DD27B9, 0x4FB6BEE1, 0xAD17F088, 0xAC66C920, 0x3AB47DCE
	,0x4A1863DF, 0x3182E51A, 0x33609751, 0x7F456253, 0x77E0B164
	,0xAE84BB6B, 0xA01CFE81, 0x2B94F908, 0x68587048, 0xFD198F45
	,0x6C8794DE, 0xF8B7527B, 0xD323AB73, 0x2E2724B, 0x8F57E31F
	,0xAB2A6655, 0x2807B2EB, 0xC2032FB5, 0x7B9A86C5, 0x8A5D337
	,0x87F23028, 0xA5B223BF, 0x6ABA0203, 0x825CED16, 0x1C2B8ACF
	,0xB492A779, 0xF2F0F307, 0xE2A14E69, 0xF4CD65DA, 0xBED50605
	,0x621FD134, 0xFE8AC4A6, 0x539D342E, 0x55A0A2F3, 0xE132058A
	,0xEB75A4F6, 0xEC390B83, 0xEFAA4060, 0x9F065E71, 0x1051BD6E
	,0x8AF93E21, 0x63D96DD, 0x5AEDD3E, 0xBD464DE6, 0x8DB59154
	,0x5D0571C4, 0xD46F0406, 0x15FF6050, 0xFB241998, 0xE997D6BD
	,0x43CC8940, 0x9E7767D9, 0x42BDB0E8, 0x8B880789, 0x5B38E719
	,0xEEDB79C8, 0xA47A17C, 0xFE97C42, 0x1EC9F884, 0, 0x86830980
	,0xED48322B, 0x70AC1E11, 0x724E6C5A, 0xFFFBFD0E, 0x38560F85
	,0xD51E3DAE, 0x3927362D, 0xD9640A0F, 0xA621685C, 0x54D19B5B
	,0x2E3A2436, 0x67B10C0A, 0xE70F9357, 0x96D2B4EE, 0x919E1B9B
	,0xC54F80C0, 0x20A261DC, 0x4B695A77, 0x1A161C12, 0xBA0AE293
	,0x2AE5C0A0, 0xE0433C22, 0x171D121B, 0xD0B0E09, 0xC7ADF28B
	,0xA8B92DB6, 0xA9C8141E, 0x198557F1, 0x74CAF75, 0xDDBBEE99
	,0x60FDA37F, 0x269FF701, 0xF5BC5C72, 0x3BC54466, 0x7E345BFB
	,0x29768B43, 0xC6DCCB23, 0xFC68B6ED, 0xF163B8E4, 0xDCCAD731
	,0x85104263, 0x22401397, 0x112084C6, 0x247D854A, 0x3DF8D2BB
	,0x3211AEF9, 0xA16DC729, 0x2F4B1D9E, 0x30F3DCB2, 0x52EC0D86
	,0xE3D077C1, 0x166C2BB3, 0xB999A970, 0x48FA1194, 0x642247E9
	,0x8CC4A8FC, 0x3F1AA0F0, 0x2CD8567D, 0x90EF2233, 0x4EC78749
	,0xD1C1D938, 0xA2FE8CCA, 0xB3698D4, 0x81CFA6F5, 0xDE28A57A
	,0x8E26DAB7, 0xBFA43FAD, 0x9DE42C3A, 0x920D5078, 0xCC9B6A5F
	,0x4662547E, 0x13C2F68D, 0xB8E890D8, 0xF75E2E39, 0xAFF582C3
	,0x80BE9F5D, 0x937C69D0, 0x2DA96FD5, 0x12B3CF25, 0x993BC8AC
	,0x7DA71018, 0x636EE89C, 0xBB7BDB3B, 0x7809CD26, 0x18F46E59
	,0xB701EC9A, 0x9AA8834F, 0x6E65E695, 0xE67EAAFF, 0xCF0821BC
	,0xE8E6EF15, 0x9BD9BAE7, 0x36CE4A6F, 0x9D4EA9F, 0x7CD629B0
	,0xB2AF31A4, 0x23312A3F, 0x9430C6A5, 0x66C035A2, 0xBC37744E
	,0xCAA6FC82, 0xD0B0E090, 0xD81533A7, 0x984AF104, 0xDAF741EC
	,0x500E7FCD, 0xF62F1791, 0xD68D764D, 0xB04D43EF, 0x4D54CCAA
	,0x4DFE496, 0xB5E39ED1, 0x881B4C6A, 0x1FB8C12C, 0x517F4665
	,0xEA049D5E, 0x355D018C, 0x7473FA87, 0x412EFB0B, 0x1D5AB367
	,0xD25292DB, 0x5633E910, 0x47136DD6, 0x618C9AD7, 0xC7A37A1
	,0x148E59F8, 0x3C89EB13, 0x27EECEA9, 0xC935B761, 0xE5EDE11C
	,0xB13C7A47, 0xDF599CD2, 0x733F55F2, 0xCE791814, 0x37BF73C7
	,0xCDEA53F7, 0xAA5B5FFD, 0x6F14DF3D, 0xDB867844, 0xF381CAAF
	,0xC43EB968, 0x342C3824, 0x405FC2A3, 0xC372161D, 0x250CBCE2
	,0x498B283C, 0x9541FF0D, 0x17139A8, 0xB3DE080C, 0xE49CD8B4
	,0xC1906456, 0x84617BCB, 0xB670D532, 0x5C74486C, 0x5742D0B8

	//uknown
	,0xD56A0952, 0x38A53630, 0x9EA340BF, 0xFBD7F381, 0x8239E37C
	,0x87FF2F9B, 0x44438E34, 0xCBE9DEC4, 0x32947B54, 0x3D23C2A6
	,0xB954CEE, 0x4EC3FA42, 0x66A12E08, 0xB224D928, 0x49A25B76
	,0x25D18B6D, 0x64F6F872, 0x16986886, 0xCC5CA4D4, 0x92B6655D
	,0x5048706C, 0xDAB9EDFD, 0x5746155E, 0x849D8DA7, 0xABD890
	,0xAD3BC8C, 0x558E4F7, 0x645B3B8, 0x8F1E2CD0, 0x20F3FCA
	,0x3BDAFC1, 0x6B8A1301, 0x4111913A, 0xEADC674F, 0xCECFF297
	,0x73E6B4F0, 0x2274AC96, 0x8535ADE7, 0xE837F9E2, 0x6EDF751C
	,0x711AF147, 0x89C5291D, 0xE62B76F, 0x1BBE18AA, 0x4B3E56FC
	,0x2079D2C6, 0xFEC0DB9A, 0xF45ACD78, 0x33A8DD1F, 0x31C70788
	,0x591012B1, 0x5FEC8027, 0xA97F5160, 0xD4AB519, 0x9F7AE52D
	,0xEF9CC993, 0x4D3BE0A0, 0xB0F52AAE, 0x3CBBEBC8, 0x61995383
	,0x7E042B17, 0x26D677BA, 0x631469E1, 0x7D0C2155 };





LocalListener::LocalListener()
{
	gLListener = this;
	int yes = 1;
	containerslock = PTHREAD_MUTEX_INITIALIZER;
	maincontainerslock = PTHREAD_MUTEX_INITIALIZER;
	//Init serverSock and start listen()'ing
	serverSock = socket(AF_INET, SOCK_STREAM, 0);
	memset(&serverAddr, 0, sizeof(sockaddr_in));
	serverAddr.sin_family = AF_INET;
	serverAddr.sin_addr.s_addr = INADDR_ANY;
	serverAddr.sin_port = htons(30666);

	//Avoid bind error if the socket was not close()'d last time;
	setsockopt(serverSock, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int));

	if (bind(serverSock, (struct sockaddr *) &serverAddr, sizeof(sockaddr_in)) < 0)
		printf("Failed to bind");
	
	listen(serverSock, 10);

}


LocalListener::~LocalListener()
{

}
void SendDeadActorsInfo(user_container *container)
{
	if (container->user == nullptr)
		return;
	uint64_t currentTime = GetTickCountMs();
	rapidjson::StringBuffer s;
	rapidjson::Writer<rapidjson::StringBuffer> writer(s);


	for (int i = 0; i < container->user->m_nDeadActorCnt; i++) {
		auto actor = container->user->m_DeadActor[i];
		writer.Reset(s);
		writer.StartObject();

		writer.Key("type");
		writer.String("deadactorinfo");

		writer.Key("fXPos");
		writer.Double(actor.fXPos);
		writer.Key("fYPos");
		writer.Double(actor.fYPos);
		writer.Key("fZPos");
		writer.Double(actor.fZPos);
		writer.Key("nTeamNo");
		writer.Int(actor.nTeamNo);
		writer.Key("nTimes");
		writer.Int(actor.nTimes);
		writer.Key("nType");
		writer.Int(actor.nType);
		writer.EndObject();

		SendDistrubuteServer(container, (char*)s.GetString());

	}
	



}
void SendAirDropPlaneInfo(user_container *container)
{
	if (container->user == nullptr)
		return;
	uint64_t currentTime = GetTickCountMs();
	rapidjson::StringBuffer s;
	rapidjson::Writer<rapidjson::StringBuffer> writer(s);


	for (int i = 0; i < container->user->m_nDrawAirDropPlaneCnt; i++) {
		auto plane = container->user->m_DrawAirDropPlane[i];


		writer.Reset(s);
		writer.StartObject();

		writer.Key("type");
		writer.String("airdropplane");


		writer.Key("bAirDropVisible");
		writer.Bool(plane.bAirDropVisible);
		writer.Key("dwGetTickCnt");
		writer.Double(plane.dwGetTickCnt);
		writer.Key("fCurX");
		writer.Double(plane.fCurX);
		writer.Key("fCurY");
		writer.Double(plane.fCurY);
		writer.Key("fDirX");
		writer.Double(plane.fDirX);
		writer.Key("fSpeed");
		writer.Double(plane.fSpeed);
		writer.Key("fXPos");
		writer.Double(plane.fXPos);
		writer.Key("fYPos");
		writer.Double(plane.fYPos);
		writer.Key("fZPos");
		writer.Double(plane.fZPos);

		writer.EndObject();
		SendDistrubuteServer(container, (char*)s.GetString());

	}

}
void SendDistrubuteServer(user_container *container, char *json)
{
	for (auto i = gLListener->wsHandles.begin(); i != gLListener->wsHandles.end(); i++) {
		//for now
		gLListener->wsServer->send(*i, json, websocketpp::frame::opcode::text);
	}

	

	/*
	
	struct sockaddr_in     servaddr;
	struct hostent *he;
	struct sockaddr_in their_addr; 

	memset(&servaddr, 0, sizeof(servaddr));
	he = gethostbyname("127.0.0.1");
	their_addr.sin_family = AF_INET;     
	their_addr.sin_port = htons(12000); 
	their_addr.sin_addr = *((struct in_addr *)he->h_addr);
	bzero(&(their_addr.sin_zero), 8);    


	int n, len;

	sendto(container->distrbute_sockfd, (const char *)json, strlen(json),
		MSG_CONFIRM, (const struct sockaddr *) &their_addr,
		sizeof(struct sockaddr));


	*/


}

void SendCircleInfo(user_container * container)
{
	if (container->user == nullptr)
		return;
	auto circle = container->user->m_CircleInfo;
	if (circle.fBlueR == 0.0 && circle.fWhiteR == 0.0)
		return;

	rapidjson::StringBuffer s;
	rapidjson::Writer<rapidjson::StringBuffer> writer(s);
	writer.StartObject();
	writer.Key("userid");
	writer.String("");
	
	writer.Key("type");
	writer.String("circleinfo");



	writer.Key("bRestictionStart");
	writer.Bool(circle.bRestictionStart);

	writer.Key("fTime");
	writer.Double(circle.fTime);


	writer.Key("dwTickStartCnt");
	writer.Uint(circle.dwTickStartCnt);





	writer.Key("fBlueR");
	writer.Double(circle.fBlueR);

	writer.Key("fBlueX");
	writer.Double(circle.fBlueX);

	writer.Key("fBlueY");
	writer.Double(circle.fBlueY);

	writer.Key("fWhiteR");
	writer.Double(circle.fWhiteR);

	writer.Key("fWhiteX");
	writer.Double(circle.fWhiteX);

	writer.Key("fWhiteY");
	writer.Double(circle.fWhiteY);



	writer.EndObject();
	
	SendDistrubuteServer(container, (char*)s.GetString());
}
void SendItemInfo(user_container *container) {
	if (container->user == nullptr)
		return;
	/*if (container->user->m_nDrawItemCnt == 0)
		return;*/
	rapidjson::StringBuffer s;
	rapidjson::Writer<rapidjson::StringBuffer> writer(s);
	

	for (int i = 0; i < container->user->m_nDrawItemCnt; i++)
	{
		writer.Reset(s);
		

		writer.StartObject();
		auto item = container->user->m_DrawItem[i];
		writer.Key("type");
		writer.String("iteminfo");
		writer.Key("bVisible");
		writer.Bool(item.bVisible);


		writer.Key("fXPos");
		writer.Double(item.fXPos);

		writer.Key("fYPos");
		writer.Double(item.fYPos);

		writer.Key("fZPos");
		writer.Double(item.fZPos);

		writer.Key("fYaw");
		writer.Double(item.fYaw);

		writer.Key("nGUID");
		writer.Uint(item.nGUID);

		writer.Key("nItemIndex");
		writer.Uint(item.nItemIndex);

		writer.Key("nTypeGUID");
		writer.Uint(item.nTypeGUID);

		writer.EndObject();
		SendDistrubuteServer(container, (char*)s.GetString());

	}

	

}
void SendActorInfo(user_container *container) {
	if (container->user == nullptr)
		return;
	/*if (container->user->m_nDrawActorCnt == 0)
		return;*/
	rapidjson::StringBuffer s;
	rapidjson::Writer<rapidjson::StringBuffer> writer(s);
	writer.StartObject();
	writer.Key("userid");
	writer.String("");

	writer.Key("type");
	writer.String("actorsinfo");

	writer.Key("items");
	writer.StartArray();

	for (int i = 0; i < container->user->m_nDrawActorCnt; i++)
	{
		writer.StartObject();
		auto actor = container->user->m_DrawActors[i];

		writer.Key("bVisible");
		writer.Bool(actor.bVisible);


		writer.Key("fXPos");
		writer.Double(actor.fXPos);

		writer.Key("fYPos");
		writer.Double(actor.fYPos);

		writer.Key("fZPos");
		writer.Double(actor.fZPos);

		writer.Key("fYaw");
		writer.Double(actor.fYaw);

		writer.Key("bDead");
		writer.Bool(actor.bDead);

		writer.Key("bVehicle");
		writer.Bool(actor.bVehicle);


		writer.Key("dwReceiveDataTime");
		writer.Uint(actor.dwReceiveDataTime);

		writer.Key("fSeverTime");
		writer.Double(actor.fSeverTime);


		writer.Key("fVelX");
		writer.Double(actor.fVelX);


		writer.Key("fVelY");
		writer.Double(actor.fVelY);


		writer.Key("fVelZ");
		writer.Double(actor.fVelZ);


		writer.Key("nActorChannelIndex");
		writer.Uint(actor.nActorChannelIndex);

		writer.Key("nAttachParent");
		writer.Uint(actor.nAttachParent);

		writer.Key("nChangeCnt");
		writer.Int(actor.nChangeCnt);

		writer.Key("nErrorCnt");
		writer.Int(actor.nErrorCnt);

		writer.Key("nInstigator");
		writer.Uint(actor.nInstigator);
		
		writer.Key("nMoveMode");
		writer.Uint(actor.nMoveMode);

		writer.Key("nStateID");
		writer.Int(actor.nStateID);

		writer.Key("nTeamID");
		writer.Uint(actor.nTeamID);


		writer.Key("nTeamIndex");
		writer.Uint(actor.nTeamIndex);

		writer.Key("nTeamNo");
		writer.Int(actor.nTeamNo);

		writer.Key("nTimes");
		writer.Int(actor.nTimes);

		writer.Key("nType");
		writer.Int(actor.nType);


		writer.Key("nVehicleParent");
		writer.Uint(actor.nVehicleParent);

		writer.Key("nVehicleSeat");
		writer.Uint(actor.nVehicleSeat);


		writer.Key("nVehicleSeatIdx");
		writer.Uint(actor.nVehicleSeatIdx);

		writer.Key("nVirtualID");
		writer.Int(actor.nVirtualID);
		writer.EndObject();
	}

	writer.EndArray();



	writer.EndObject();

	//printf("SendVehicleInfo %s", (char*)s.GetString());
	std::size_t currenctHash = std::hash<std::string>{}(s.GetString());
	if (container->user->actorinfohash != currenctHash)
	{
		container->user->actorinfohash = currenctHash;
		SendDistrubuteServer(container, (char*)s.GetString());
	}


}
void SendVehicleInfo(user_container *container) {
	if (container->user == nullptr)
		return;
/*	if (container->user->m_nDrawVehicleCnt == 0)
		return;*/

	auto circle = container->user->m_CircleInfo;
	rapidjson::StringBuffer s;
	rapidjson::Writer<rapidjson::StringBuffer> writer(s);
	writer.StartObject();
	writer.Key("userid");
	writer.String("");

	writer.Key("type");
	writer.String("vehicleinfo");

	writer.Key("vehicles");
	writer.StartArray();

	for (int i = 0; i < container->user->m_nDrawVehicleCnt; i++)
	{
		writer.StartObject();
		auto vehicle = container->user->m_DrawVehicles[i];

		writer.Key("bVisible");
		writer.Bool(vehicle.bVisible);
		
		writer.Key("dwReceiveDataTime");
		writer.Uint(vehicle.dwReceiveDataTime);

		writer.Key("fVelX");
		writer.Double(vehicle.fVelX);

		writer.Key("fVelY");
		writer.Double(vehicle.fVelY);

		writer.Key("fVelZ");
		writer.Double(vehicle.fVelZ);

		writer.Key("fXPos");
		writer.Double(vehicle.fXPos);

		writer.Key("fYaw");
		writer.Double(vehicle.fYaw);

		writer.Key("fYPos");
		writer.Double(vehicle.fYPos);

		writer.Key("fZPos");
		writer.Double(vehicle.fZPos);

		writer.Key("nInstigator");
		writer.Uint(vehicle.nInstigator);

		writer.Key("nNum0");
		writer.Uint(vehicle.nNum[0]);
		writer.Key("nNum1");
		writer.Uint(vehicle.nNum[1]);
		writer.Key("nNum2");
		writer.Uint(vehicle.nNum[2]);
		writer.Key("nNum3");
		writer.Uint(vehicle.nNum[3]);



		writer.Key("nSeatCnt");
		writer.Int(vehicle.nSeatCnt);

		writer.Key("nTypeGUID");
		writer.Uint(vehicle.nTypeGUID);



		writer.EndObject();
	}

	writer.EndArray();



	writer.EndObject();

	//printf("SendVehicleInfo %s", (char*)s.GetString());
	std::size_t currenctHash = std::hash<std::string>{}(s.GetString());
	if (container->user->vehicleHash != currenctHash)
	{
		container->user->vehicleHash = currenctHash;
		SendDistrubuteServer(container, (char*)s.GetString());
	}
}
void SendAirAttackAreaInfo(user_container *container) {
}
void InsertDrawVehicle(user_container *container,pVEHICLE_INFO pVehicle)
{
	int i = 0;
	float fTickTemp = ((float)(GetTickCountMs() - pVehicle->dwReceiveDataTime)) / 1000;
	container->user->m_DrawVehicles[container->user->m_nDrawVehicleCnt].fXPos = pVehicle->fXPos + (pVehicle->fVelX * fTickTemp);
	container->user->m_DrawVehicles[container->user->m_nDrawVehicleCnt].fYPos = pVehicle->fYPos + (pVehicle->fVelY * fTickTemp);
	container->user->m_DrawVehicles[container->user->m_nDrawVehicleCnt].fZPos = pVehicle->fZPos + (pVehicle->fVelZ * fTickTemp);


	container->user->m_DrawVehicles[container->user->m_nDrawVehicleCnt].fYaw = pVehicle->fYaw;
		for (i = 0; i < 4; i++)
		{
			container->user->m_DrawVehicles[container->user->m_nDrawVehicleCnt].nNum[i] = pVehicle->nNum[i];
		}
		container->user->m_DrawVehicles[container->user->m_nDrawVehicleCnt].nSeatCnt = pVehicle->nSeatCnt;
		container->user->m_nDrawVehicleCnt++;
	
}
uint64_t GetTickCountMs()
{
	struct timespec ts;

	clock_gettime(CLOCK_MONOTONIC, &ts);

	return (uint64_t)(ts.tv_nsec / 1000000) + ((uint64_t)ts.tv_sec * 1000ull);
}
void InsertDrawAirDropPlane(user_container *container,PAIR_DROP_PLANE pAirDropPlane)
{
	int i = 0;
	container->user->m_DrawAirDropPlane[container->user->m_nDrawAirDropPlaneCnt].fXPos = pAirDropPlane->fXPos;
	container->user->m_DrawAirDropPlane[container->user->m_nDrawAirDropPlaneCnt].fYPos = pAirDropPlane->fYPos;
	container->user->m_DrawAirDropPlane[container->user->m_nDrawAirDropPlaneCnt].fDirX = pAirDropPlane->fDirX;
	container->user->m_DrawAirDropPlane[container->user->m_nDrawAirDropPlaneCnt].fDirY = pAirDropPlane->fDirY;
	container->user->m_DrawAirDropPlane[container->user->m_nDrawAirDropPlaneCnt].fSpeed = pAirDropPlane->fSpeed;
	container->user->m_DrawAirDropPlane[container->user->m_nDrawAirDropPlaneCnt].bAirDropVisible = pAirDropPlane->bAirDropVisible;
	container->user->m_DrawAirDropPlane[container->user->m_nDrawAirDropPlaneCnt].dwGetTickCnt = pAirDropPlane->dwGetTickCnt;

	container->user->m_nDrawAirDropPlaneCnt++;
}
void SelectDrawActors(user_container *container)
{
	ACTOR otherActor, actor;
	container->user->m_nDrawActorCnt = 0;
	container->user->m_nDrawVehicleCnt = 0;
	container->user->m_nDrawItemCnt = 0;
	container->user->m_nDrawAirDropPlaneCnt = 0;
	for (int i = 0; i < container->user->m_nChannelCnt; i++)
	{
		if (container->user->m_channel[i].bChannelOpen)
		{
			if ((container->user->m_channel[i].pActor) && (container->user->m_channel[i].pActor->bDraw) && (container->user->m_channel[i].pActor->bVisible))
			{
				
				float fTickTemp = ((float)(GetTickCountMs() - container->user->m_channel[i].pActor->dwReceiveDataTime)) / 1000;
				actor.fXPos = container->user->m_channel[i].pActor->fXPos + (container->user->m_channel[i].pActor->fVelX * fTickTemp);
				actor.fYPos = container->user->m_channel[i].pActor->fYPos + (container->user->m_channel[i].pActor->fVelY * fTickTemp);
				actor.fZPos = container->user->m_channel[i].pActor->fZPos + (container->user->m_channel[i].pActor->fVelZ * fTickTemp);
				actor.fYaw = container->user->m_channel[i].pActor->fYaw;
				actor.nTeamID = container->user->m_channel[i].pActor->nTeamID;
				if ((container->user->m_channel[i].pActor->nType == 1))
				{
					for (int j = 0; j < container->user->m_nTeammateCnt; j++)
					{
						if (container->user->m_channel[i].pActor->nStateID == container->user->m_nTeamRealID[j])
						{
							container->user->m_channel[i].pActor->nTeamNo = container->user->m_nTeamNo[j];
							container->user->m_TeamActor[j].bVisible = false;
							if (container->user->m_nTeamNetGUID[j] == 0x77777777)
							{
								container->user->m_nTeamNetGUID[j] = container->user->m_channel[i].nNetGUID;
							}
							break;
						}
					}
				}
				actor.nTeamNo = container->user->m_channel[i].pActor->nTeamNo;
				actor.nInstigator = container->user->m_channel[i].pActor->nInstigator;
				actor.nAttachParent = container->user->m_channel[i].pActor->nAttachParent;
				actor.nType = container->user->m_channel[i].pActor->nType;
				actor.bVisible = true;


				container->user->m_DrawActors[container->user->m_nDrawActorCnt] = actor;
				container->user->m_nDrawActorCnt++;
			}
			else if (container->user->m_channel[i].pVehicle)
			{
				InsertDrawVehicle(container,container->user->m_channel[i].pVehicle);
			}
			else if ((container->user->m_channel[i].pItem) && (container->user->m_channel[i].pItem->bVisible))
			{

				container->user->m_DrawItem[container->user->m_nDrawItemCnt].fXPos = container->user->m_channel[i].pItem->fXPos;
				container->user->m_DrawItem[container->user->m_nDrawItemCnt].fYPos = container->user->m_channel[i].pItem->fYPos;
				container->user->m_DrawItem[container->user->m_nDrawItemCnt].nItemIndex = container->user->m_channel[i].pItem->nItemIndex;
				container->user->m_DrawItem[container->user->m_nDrawItemCnt].nTypeGUID = container->user->m_channel[i].pItem->nTypeGUID;
				container->user->m_nDrawItemCnt++;

			}
			else if (container->user->m_channel[i].pAirDropPlane && container->user->m_channel[i].pAirDropPlane->bAirDropVisible)
			{
				DWORD dwCurCnt = GetTickCountMs() - container->user->m_channel[i].pAirDropPlane->dwGetTickCnt;
				float fCurX, fCurY;
				fCurX = container->user->m_channel[i].pAirDropPlane->fXPos + (((float)dwCurCnt) / 1000) * container->user->m_channel[i].pAirDropPlane->fDirX * container->user->m_channel[i].pAirDropPlane->fSpeed;
				fCurY = container->user->m_channel[i].pAirDropPlane->fYPos + (((float)dwCurCnt) / 1000) * container->user->m_channel[i].pAirDropPlane->fDirY * container->user->m_channel[i].pAirDropPlane->fSpeed;
				if ((fCurY > 1000000) || (fCurY < -10000) || (fCurX > 1000000) || (fCurX < -10000))
				{
					container->user->m_channel[i].pAirDropPlane->bAirDropVisible = false;
				}
				InsertDrawAirDropPlane(container, container->user->m_channel[i].pAirDropPlane);
			}
		}

	}
	for (int i = container->user->m_nShootInfoCnt - 1; i >= 0; i--)
	{
		container->user->m_arShootInfo[i].nTimes--;
		if (container->user->m_arShootInfo[i].nTimes == 0)
		{
			container->user->m_nShootInfoCnt--;
			// RemoveShootInfo(i);
		}
	}

	for (int i = 0; i < container->user->m_nTeammateCnt; i++)
	{
		if ((container->user->m_TeamActor[i].bVisible) && (container->user->m_TeamActor[i].bDead == false))
		{
			actor.fXPos = container->user->m_TeamActor[i].fXPos;
			actor.fYPos = container->user->m_TeamActor[i].fYPos;
			actor.fZPos = container->user->m_TeamActor[i].fZPos;
			actor.fYaw = container->user->m_TeamActor[i].fYaw;
			actor.nTeamNo = container->user->m_nTeamNo[i];
			actor.nInstigator = container->user->m_TeamActor[i].nInstigator;
			actor.nType = 1;
			actor.bVisible = true;
			container->user->m_DrawActors[container->user->m_nDrawActorCnt] = actor;
			container->user->m_nDrawActorCnt++;
		}
	}

	if ((container->user->m_myActor.bDraw) && (container->user->m_myActor.bDead == false))
	{
		DWORD dwTickTemp = GetTickCountMs();
		if ((abs(container->user->m_myActor.fXPos - container->user->m_myActorTemp.fXPos) >= 10000) || (abs(container->user->m_myActor.fYPos - container->user->m_myActorTemp.fYPos) >= 10000) || (abs(container->user->m_myActor.fZPos - container->user->m_myActorTemp.fZPos) >= 10000))
		{
			float fTickTemp = ((float)(GetTickCountMs() - container->user->m_myActor.dwReceiveDataTime)) / 1000;
			actor.fXPos = container->user->m_myActor.fXPos;
			actor.fYPos = container->user->m_myActor.fYPos;
			actor.fZPos = container->user->m_myActor.fZPos;
			actor.fYaw = container->user->m_myActor.fYaw;
			actor.nTeamID = container->user->m_myActor.nTeamID;
			actor.nInstigator = container->user->m_myActor.nInstigator;
			actor.nAttachParent = container->user->m_myActor.nAttachParent;
			actor.nType = 0;
			actor.bVisible = true;
		}
		else if (dwTickTemp - container->user->m_myActor.dwReceiveDataTime + 50 >= container->user->m_myActor.dwReceiveDataTime - container->user->m_myActorTemp.dwReceiveDataTime)
		{
			float fTickTemp = ((float)(GetTickCountMs() - container->user->m_myActor.dwReceiveDataTime)) / 1000;
			actor.fXPos = container->user->m_myActor.fXPos;
			actor.fYPos = container->user->m_myActor.fYPos;
			actor.fZPos = container->user->m_myActor.fZPos;
			actor.fYaw = container->user->m_myActor.fYaw;
			actor.nTeamID = container->user->m_myActor.nTeamID;
			actor.nInstigator = container->user->m_myActor.nInstigator;
			actor.nAttachParent = container->user->m_myActor.nAttachParent;
			actor.nType = 0;
			actor.bVisible = true;
		}
		else
		{
			float fTickTempCur = ((float)(dwTickTemp - container->user->m_myActor.dwReceiveDataTime + 50)) / 1000;
			float fTickTempLater = ((float)(container->user->m_myActor.dwReceiveDataTime - container->user->m_myActorTemp.dwReceiveDataTime)) / 1000;
			float fTimeXX = fTickTempCur / fTickTempLater;
			actor.fXPos = container->user->m_myActorTemp.fXPos + (container->user->m_myActor.fXPos - container->user->m_myActorTemp.fXPos) * fTimeXX;
			actor.fYPos = container->user->m_myActorTemp.fYPos + (container->user->m_myActor.fYPos - container->user->m_myActorTemp.fYPos) * fTimeXX;
			actor.fZPos = container->user->m_myActorTemp.fZPos + (container->user->m_myActor.fZPos - container->user->m_myActorTemp.fZPos) * fTimeXX;
			actor.fYaw = container->user->m_myActor.fYaw;
			actor.nTeamID = container->user->m_myActor.nTeamID;
			actor.nInstigator = container->user->m_myActor.nInstigator;
			actor.nAttachParent = container->user->m_myActor.nAttachParent;
			actor.nType = 0;
			actor.bVisible = true;
		}
		container->user->m_DrawActors[container->user->m_nDrawActorCnt] = actor;
		container->user->m_nDrawActorCnt++;
	}
}
void *DrawThread(void *p) {
	user_container	*container = (user_container*)p;
	while (container->_running) {
		if (container->user == nullptr || container->user->m_nMapIndex == 0)
		{
			sleep(1);
			continue;
		}
		pthread_mutex_lock(&container->lock);
		SelectDrawActors(container);
		SendDeadActorsInfo(container);
		SendCircleInfo(container);
		SendAirDropPlaneInfo(container);
		SendVehicleInfo(container);
		SendItemInfo(container);
		SendActorInfo(container);
		if (container->user->m_AirAttackArea.bVisible)
			SendAirAttackAreaInfo(container);
		pthread_mutex_unlock(&container->lock);


		usleep(50000);
	}



}
void *RecvThread(void *psock)
{
	arg_struct *p2 = (arg_struct*)psock;
	user_container	*p= (user_container*)p2->c;
	int sock = p->socket;
	LocalListener *l = p2->l;

	char buffer[2048], message[256];
	int index;
	int n;

	while (p->_running) {
		memset(buffer, 0, sizeof buffer);
		n = recv(sock, buffer, sizeof buffer, 0);
		//Client disconnected?
		if (n == 0) {

			return psock;
		}
		else if (n < 0) {
			return psock;
		}
		else {

			/*
			First byte structure
			1	=	TCP_RECV
			2	=	TCP_SEND
			3	=	UDP_RECV
			4	=	UDP_SEND
			*/
			int type = (int)buffer[0];
			int userId = *(int*)(buffer+1);
			

			if (p->user == nullptr)
				l->getOrCreateSharedContainer(p,userId);
			
			pthread_mutex_lock(&p->lock);
			p->user->lastResponseTime = GetTickCountMs();
			if (type == 1 || type == 2) {
				l->printTcpPacket(p,buffer + 5, n - 5);
			}
			else if (type == 3 || type == 4)
			{
				printf("udp type %d\n", type);
				l->printUdpPacket(p, buffer + 5, n - 5, type == 3);
			}
			pthread_mutex_unlock(&p->lock);


		}
	}




	return  psock;
}
void LocalListener::onWSMessage(connection_hdl hdl, server::message_ptr msg) {
	
}
void LocalListener::onWSClose(connection_hdl hdl) {

}
void LocalListener::onWSOpen(connection_hdl hdl) {
	
	wsHandles.push_back(hdl);

}
void *WSThread(void *p) {
	LocalListener *ll = (LocalListener*)p;
	server *wsserver = new server();
	
	ll->wsServer = wsserver;

	wsserver->set_access_channels(websocketpp::log::alevel::all);
	wsserver->clear_access_channels(websocketpp::log::alevel::frame_payload);
	wsserver->init_asio();
	



	wsserver->set_message_handler(bind(&LocalListener::onWSMessage, ll, ::_1, ::_2));
	wsserver->set_close_handler(bind(&LocalListener::onWSClose, ll, ::_1));
	wsserver->set_open_handler(bind(&LocalListener::onWSOpen, ll, ::_1));


	wsserver->listen(9012);

	wsserver->start_accept();

	wsserver->run();
}
void LocalListener::startAcceptingWS() {
	pthread_t pthread;
	pthread_create(&pthread, NULL, WSThread, (void*)this);
	


}
void LocalListener::printUdpPacket(user_container * container,const char *data, int length, bool bRecv)
{
	printRawData(container,data , length , bRecv);
}

#define _ROR_(nData, nBit)    ((nData >> nBit) | (nData << (32 - nBit)))

int LocalListener::DecodeUDPPacket_sub_F12680(user_container * container, char* Src, char* Dest, signed int nLen)
{
	int nIndex0 = 0;
	int nCounter = 0;
	char* lpszEncBuffer = 0;
	DWORD dwEncBuffer_0[16];
	DWORD dwEncBuffer_1[16];

	DWORD v16;
	DWORD v26;
	DWORD v31;
	DWORD v35;
	DWORD v36;
	DWORD v37;
	DWORD v38;
	DWORD v39;
	DWORD v40;
	DWORD v41;
	DWORD v42;
	DWORD v43;
	DWORD v44;
	DWORD v45; // r1@12
	DWORD v46; // ST74_4@12
	DWORD v47; // r4@12
	DWORD v48; // r12@12
	DWORD v49; // r5@12
	DWORD v50; // off@12
	DWORD v51; // ST8C_4@12
	DWORD v52; // off@12
	DWORD v53; // ST88_4@12
	DWORD v54; // off@12
	DWORD v55; // ST78_4@12
	DWORD v56; // r5@12
	DWORD v57; // off@12
	DWORD v58; // r1@12
	DWORD v59; // off@12
	DWORD v60; // ST80_4@12
	DWORD v61; // ST7C_4@12
	DWORD v62; // r9@12
	DWORD v63; // off@12
	DWORD v64; // lr@12
	DWORD v65; // off@12
	DWORD v66; // r7@12
	DWORD v67; // r6@12
	DWORD v68; // off@12
	DWORD v69; // r10@12
	DWORD v70; // off@12
	DWORD v71; // ST84_4@12
	DWORD v72; // r7@12
	DWORD v73; // off@12
	DWORD v74; // r4@12
	DWORD v75; // off@12
	DWORD v76; // r8@12
	DWORD v77; // r10@12
	DWORD v78; // off@12
	DWORD v79; // r12@12
	DWORD v80; // off@12
	DWORD v81; // r3@12
	DWORD v82; // r6@12
	DWORD v83; // off@12
	DWORD v84; // r0@12
	DWORD v85; // off@12
	DWORD v86; // r1@12
	DWORD v87; // off@12
	DWORD v88; // r2@12
	DWORD v89; // off@12
	DWORD v90; // r10@12
	DWORD v91; // off@12
	DWORD v92; // r0@12
	DWORD v93; // off@12
	DWORD v94; // r0@12
	DWORD v95; // off@12
	DWORD v96; // r1@12
	DWORD v97; // off@12
	DWORD v98; // r0@12
	DWORD v99; // off@12
	DWORD v100; // r1@12
	DWORD v101; // off@12
	DWORD v102; // r0@12
	DWORD v103; // off@12
	DWORD v104; // r2@12
	DWORD v105; // off@12
	DWORD v106; // off@12
	DWORD v107; // r0@12
	DWORD v108; // off@12
	DWORD v109; // r3@12
	DWORD v110; // off@12
	DWORD v111; // r6@12
	DWORD v112; // off@12
	DWORD v113; // r4@12
	DWORD v114; // off@12
	DWORD v115; // r0@12
	DWORD v116; // off@12
	DWORD v117; // off@12
	DWORD v118; // r3@12
	DWORD v119; // off@12
	DWORD v120; // off@12
	DWORD v121; // off@12
	DWORD v122; // off@12
	DWORD v123; // off@12
	DWORD v124; // r0@12
	DWORD v125; // off@12
	DWORD v126; // r3@12
	DWORD v127; // off@12
	DWORD v128; // r6@12
	DWORD v129; // off@12
	DWORD v130; // r7@12
	DWORD v131; // off@12
	DWORD v132; // r2@12
	DWORD v133; // off@12
	DWORD v134; // r3@12
	DWORD v135; // off@12
	DWORD v136; // off@12
	DWORD v137; // r7@12
	DWORD v138; // off@12
	DWORD v139; // off@12
	DWORD v140; // r6@12
	DWORD v141; // off@12
	DWORD v142; // off@12
	DWORD v143; // off@12
	DWORD v144; // r2@12
	DWORD v145; // off@12
	DWORD v146; // r3@12
	DWORD v147; // off@12
	DWORD v148; // r1@12
	DWORD v149; // off@12
	DWORD v150; // r0@12
	DWORD v151; // off@12
	DWORD v152; // r2@12
	DWORD v153; // off@12
	DWORD v154; // off@12
	DWORD v155; // r1@12
	DWORD v156; // off@12
	DWORD v157; // off@12
	DWORD v158; // off@12
	DWORD v159; // off@12
	DWORD v160; // off@12
	DWORD v187;
	DWORD v188;
	DWORD v189;
	DWORD v190;
	DWORD v193;
	DWORD v194;
	DWORD v195;
	DWORD v196;
	DWORD v197;
	DWORD v198;
	DWORD v199;
	DWORD v200;
	DWORD v201;
	DWORD v202;
	DWORD v203;
	DWORD v204;
	signed int v205;
	DWORD v206;

	char * szDecKey_3F21350 = container->user->g_szPacketDecodeKey_3F21350;
	char * szDecKey_3F213A0 = container->user->g_szPacketDecodeKey_3F213A0;


	v190 = *(DWORD*)(szDecKey_3F21350 + 8);
	v199 = *(DWORD*)(szDecKey_3F21350 + 4);
	v189 = *(DWORD*)(szDecKey_3F21350);
	v198 = *(DWORD*)(szDecKey_3F213A0 + 28);
	v197 = *(DWORD*)(szDecKey_3F213A0 + 24);
	v196 = *(DWORD*)(szDecKey_3F213A0 + 20);
	v195 = *(DWORD*)(szDecKey_3F213A0 + 16);
	v188 = *(DWORD*)(szDecKey_3F213A0 + 12);
	v187 = *(DWORD*)(szDecKey_3F213A0 + 8);
	v194 = *(DWORD*)(szDecKey_3F213A0 + 4);
	v193 = *(DWORD*)szDecKey_3F213A0;
	v16 = 1;
	while (nIndex0 < nLen)
	{
		lpszEncBuffer = (char*)dwEncBuffer_1;

		v43 = 22;
		v38 = v194;
		v31 = 0x3320646E;
		v36 = v198;
		v26 = v189;
		v41 = v190;
		v203 = v196;
		v206 = v199;
		v35 = v187;
		v37 = v197;
		v42 = 0x79622D32;
		v200 = v16;
		v201 = v200;
		v202 = v193;
		v39 = 0x61707865;
		v40 = v195;
		v204 = v188;
		v205 = 0x6B206574;
		do
		{
			v44 = v43;
			v45 = v38 + v31;
			v46 = v36;
			v47 = (v38 + v31) ^ v26;
			v48 = v41;
			v50 = _ROR_((DWORD)v47, 16);
			v49 = v203 + v50;
			v51 = (v203 + v50) ^ v38;
			v52 = _ROR_((DWORD)v51, 20);
			v53 = v45 + v52;
			v54 = _ROR_((DWORD)v47, 16);
			v55 = v53 ^ v54;
			v57 = _ROR_((DWORD)(v53 ^ v54), 24);
			v56 = v49 + v57;
			v58 = (v35 + v42) ^ v206;
			v59 = _ROR_((DWORD)v58, 16);
			v60 = v37 + v59;
			v61 = (v37 + v59) ^ v35;
			v63 = _ROR_((DWORD)v61, 20);
			v62 = v35 + v42 + v63;
			v65 = _ROR_((DWORD)v58, 16);
			v64 = v62 ^ v65;
			v66 = v202 + v39;
			v68 = _ROR_((DWORD)(v66 ^ v201), 16);
			v67 = v40 + v68;
			v69 = (v40 + v68) ^ v202;
			v70 = _ROR_((DWORD)v69, 20);
			v71 = v66 + v70;
			v73 = _ROR_((DWORD)(v66 ^ v201), 16);
			v72 = v71 ^ v73;
			v75 = _ROR_((DWORD)(v71 ^ v73), 24);
			v74 = v67 + v75;
			v76 = (v204 + v205) ^ v48;
			v78 = _ROR_((DWORD)v69, 20);
			v77 = v74 ^ v78;
			v80 = _ROR_((DWORD)v76, 16);
			v79 = v46 + v80;
			v81 = (v46 + v80) ^ v204;
			v83 = _ROR_((DWORD)v81, 20);
			v82 = v204 + v205 + v83;
			v85 = _ROR_((DWORD)v77, 25);
			v84 = v82 + v85;
			v87 = _ROR_((DWORD)v64, 24);
			v86 = v84 ^ v87;
			v89 = _ROR_((DWORD)(v84 ^ v87), 16);
			v88 = v56 + v89;
			v91 = _ROR_((DWORD)v77, 25);
			v90 = v88 ^ v91;
			v93 = _ROR_((DWORD)(v88 ^ v91), 20);
			v92 = v84 + v93;
			v205 = v92;
			v95 = _ROR_((DWORD)v86, 16);
			v94 = v92 ^ v95;
			v97 = _ROR_((DWORD)v94, 24);
			v96 = v97;
			v99 = _ROR_((DWORD)v94, 24);
			v98 = v88 + v99;
			v206 = v96;
			v101 = _ROR_((DWORD)v76, 16);
			v100 = v82 ^ v101;
			v203 = v98;
			v103 = _ROR_((DWORD)v90, 20);
			v102 = v98 ^ v103;
			v105 = _ROR_((DWORD)v100, 24);
			v104 = v79 + v105;
			v106 = _ROR_((DWORD)v102, 25);
			v202 = v106;
			v108 = _ROR_((DWORD)v81, 20);
			v107 = v104 ^ v108;
			v110 = _ROR_((DWORD)(v104 ^ v108), 25);
			v109 = v62 + v110;
			v112 = _ROR_((DWORD)v55, 24);
			v111 = v109 ^ v112;
			v114 = _ROR_((DWORD)(v109 ^ v112), 16);
			v113 = v74 + v114;
			v116 = _ROR_((DWORD)v107, 25);
			v115 = v113 ^ v116;
			v117 = _ROR_((DWORD)(v113 ^ v116), 20);
			v42 = v109 + v117;
			v119 = _ROR_((DWORD)v111, 16);
			v118 = v42 ^ v119;
			v120 = _ROR_((DWORD)(v42 ^ v119), 24);
			v40 = v113 + v120;
			v121 = _ROR_((DWORD)v118, 24);
			v26 = v121;
			v122 = _ROR_((DWORD)v115, 20);
			v123 = _ROR_((DWORD)(v40 ^ v122), 25);
			v204 = v123;
			v125 = _ROR_((DWORD)v64, 24);
			v124 = v60 + v125;
			v127 = _ROR_((DWORD)v61, 20);
			v126 = v124 ^ v127;
			v129 = _ROR_((DWORD)(v124 ^ v127), 25);
			v128 = v53 + v129;
			v131 = _ROR_((DWORD)v72, 24);
			v130 = v128 ^ v131;
			v133 = _ROR_((DWORD)(v128 ^ v131), 16);
			v132 = v104 + v133;
			v135 = _ROR_((DWORD)v126, 25);
			v134 = v132 ^ v135;
			v136 = _ROR_((DWORD)(v132 ^ v135), 20);
			v31 = v128 + v136;
			v138 = _ROR_((DWORD)v130, 16);
			v137 = v31 ^ v138;
			v139 = _ROR_((DWORD)(v31 ^ v138), 24);
			v36 = v132 + v139;
			v141 = _ROR_((DWORD)v137, 24);
			v140 = v141;
			v142 = _ROR_((DWORD)v134, 20);
			v201 = v140;
			v143 = _ROR_((DWORD)(v36 ^ v142), 25);
			v35 = v143;
			v145 = _ROR_((DWORD)v51, 20);
			v144 = v56 ^ v145;
			v147 = _ROR_((DWORD)(v56 ^ v145), 25);
			v146 = v71 + v147;
			v149 = _ROR_((DWORD)v100, 24);
			v148 = v146 ^ v149;
			v151 = _ROR_((DWORD)(v146 ^ v149), 16);
			v150 = v124 + v151;
			v153 = _ROR_((DWORD)v144, 25);
			v152 = v150 ^ v153;
			v154 = _ROR_((DWORD)(v150 ^ v153), 20);
			v39 = v146 + v154;
			v156 = _ROR_((DWORD)v148, 16);
			v155 = v39 ^ v156;
			v157 = _ROR_((DWORD)(v39 ^ v156), 24);
			v37 = v150 + v157;
			v158 = _ROR_((DWORD)v155, 24);
			v41 = v158;
			v159 = _ROR_((DWORD)v152, 20);
			v43 = v44 - 2;
			v160 = _ROR_((DWORD)(v37 ^ v159), 25);
			v38 = v160;
		} while (v44 - 2 > 2);

		dwEncBuffer_0[0] = v39 + 0x61707865;
		dwEncBuffer_0[1] = v31 + 0x3320646E;
		dwEncBuffer_0[2] = v42 + 0x79622D32;
		dwEncBuffer_0[3] = v205 + 0x6B206574;
		dwEncBuffer_0[4] = v202 + v193;
		dwEncBuffer_0[5] = v38 + v194;
		dwEncBuffer_0[6] = v35 + v187;
		dwEncBuffer_0[7] = v204 + v188;
		dwEncBuffer_0[8] = v40 + v195;
		dwEncBuffer_0[9] = v203 + v196;
		dwEncBuffer_0[10] = v37 + v197;
		dwEncBuffer_0[11] = v36 + v198;
		dwEncBuffer_0[12] = v201 + v200;
		dwEncBuffer_0[13] = v26 + v189;
		dwEncBuffer_0[14] = v206 + v199;
		dwEncBuffer_0[15] = v41 + v190;

		dwEncBuffer_1[0] = dwEncBuffer_0[0];
		dwEncBuffer_1[1] = dwEncBuffer_0[1];
		dwEncBuffer_1[2] = dwEncBuffer_0[2];
		dwEncBuffer_1[3] = dwEncBuffer_0[3];
		dwEncBuffer_1[4] = dwEncBuffer_0[4];
		dwEncBuffer_1[5] = dwEncBuffer_0[5];
		dwEncBuffer_1[6] = dwEncBuffer_0[6];
		dwEncBuffer_1[7] = dwEncBuffer_0[7];
		dwEncBuffer_1[8] = dwEncBuffer_0[8];
		dwEncBuffer_1[9] = dwEncBuffer_0[9];
		dwEncBuffer_1[10] = dwEncBuffer_0[10];
		dwEncBuffer_1[11] = dwEncBuffer_0[11];
		dwEncBuffer_1[12] = dwEncBuffer_0[12];
		dwEncBuffer_1[13] = dwEncBuffer_0[13];
		dwEncBuffer_1[14] = dwEncBuffer_0[14];
		dwEncBuffer_1[15] = dwEncBuffer_0[15];

		if ((nLen - nIndex0) >= 64)
			nCounter = 64;
		else
			nCounter = nLen - nIndex0;

		for (int i = 0; i < nCounter; i++)
		{
			*(char *)(Dest + nIndex0 + i) = *(char *)(Src + nIndex0 + i) ^ lpszEncBuffer[i];
		}
		nIndex0 += 64;
		v16 = v200 + 1;
	}
	return 0;
}
void LocalListener::printRawData(user_container * container,const char *data, int length, bool bRecv)
{
	
	if (container->user->g_bPacketDecode_3F21303 == true)
	{
		

		if (length > 1024)
		{
			return;
		}
		char szDest[1024] = { 0x00 };

		DecodeUDPPacket_sub_F12680(container,(char *)data, szDest, length);
		if (bRecv)
		{
			RecvPacketFilter(container,(BYTE *)szDest, length);
		}
		else
		{
			SendPacketFilter(container,(BYTE *)szDest, length);
		}
	}
}
bool LocalListener::ChangeMyActorPlace(user_container *container,float X0, float Y0, float Z0, float X1, float Y1, float Z1)
{
	if (sqrt((X0 - X1) * (X0 - X1) + (Y0 - Y1) * (Y0 - Y1) + (Z0 - Z1) * (Z0 - Z1)) < 100000)
	{
		container->user->m_nChangeCnt = 0;
		return true;
	}
	else
		container->user->m_nChangeCnt++;
	return false;
}
void LocalListener::SendPacketFilter(user_container *container,LPBYTE pBuf, int nBufLen)
{
	CBitReader reader;
	CReceiveDataParsing parser;
	ACTOR actor;
	BYTE byteFilterHeader = 0;
	int i = 0;
	int j = 0;
	float fTimes = 0;
	BYTE bReadNext = 0;
	FVECTOR Fv, fvVel;
	FROTATOR FR;
	UINT32 nTemp;
	UINT32 nPosTemp = 0;
	BOOL bLocationValid = FALSE;
	UINT32 nBunchLen = 0;
	UINT32 nPosTemp2 = 0;
	UINT32 nIncorrectID = 0;
	
	memcpy(reader.Buffer, pBuf, nBufLen);

	reader.nNum = 8 * nBufLen;
	for (j = 6 * 8; j < (nBufLen) * 8; j++)
	{
		reader.nPos = j;
		Fv.X = 0;
		Fv.Y = 0;
		Fv.Z = 0;

		reader.ReadByteData(&byteFilterHeader, 1);
		if (byteFilterHeader == 0x80)
		{
			reader.SerializeIntPacked(nBunchLen);
			nPosTemp = reader.nPos;
			bReadNext = reader.ReadBit();
			if (bReadNext)
			{
				fTimes = reader.ReadFloat();
				if ((fTimes < 0) || (fTimes > 10000))
				{
					goto LABEL1;
				}
			}
			bReadNext = reader.ReadBit();
			if (bReadNext)
			{
				fTimes = reader.ReadFloat();
				if ((fTimes < 0) || (fTimes > 10000))
				{
					goto LABEL1;
				}
			}
			bReadNext = reader.ReadBit();
			if (bReadNext)
			{
				parser.ReadPackedVector<100, 30>(Fv, reader);
			}
			bReadNext = reader.ReadBit();
			if (bReadNext)
			{
				fTimes = reader.ReadFloat();
				if ((fTimes < 0) || (fTimes > 800000))
				{
					goto LABEL1;
				}
			}
			if ((reader.nPos - nPosTemp) == nBunchLen)
			{
				if ((Fv.X > 10000) && (Fv.X < 800000) && (Fv.Y > 10000) && (Fv.Y < 800000) && (Fv.Z > -1000) && (Fv.Z < 150001))
				{
					if (container->user->m_myActor.dwReceiveDataTime != 0x00)
					{
						memcpy(&container->user->m_myActorTemp, &(container->user->m_myActor), sizeof(container->user->m_myActorTemp));
					}
					if (container->user->m_myActor.bDraw == false)
					{
						container->user->m_myActor.bDraw = true;
					}
					if (ChangeMyActorPlace(container,container->user->m_myActor.fXPos, container->user->m_myActor.fYPos, container->user->m_myActor.fZPos, Fv.X, Fv.Y, Fv.Z))
					{
						container->user->m_myActor.fXPos = Fv.X;
						container->user->m_myActor.fYPos = Fv.Y;
						container->user->m_myActor.fZPos = Fv.Z;
					}
					if (container->user->m_nChangeCnt > 3)
					{
						container->user->m_myActor.fXPos = Fv.X;
						container->user->m_myActor.fYPos = Fv.Y;
						container->user->m_myActor.fZPos = Fv.Z;
					}
					container->user->m_myActor.dwReceiveDataTime = GetTickCountMs();
					continue;
				}
			}


		}
	LABEL1:
		reader.nPos = j;
		reader.ReadByteData(&byteFilterHeader, 1);
		if ((byteFilterHeader == 0x80) || (byteFilterHeader == 0xa0))
		{
			reader.SerializeIntPacked(nBunchLen);
			nPosTemp = reader.nPos;
			bReadNext = reader.ReadBit();
			if (bReadNext)
			{
				reader.ReadByteData((BYTE *)&nIncorrectID, 4);
			}
			bReadNext = reader.ReadBit();
			if (bReadNext)
			{
				fTimes = reader.ReadFloat();
				if ((fTimes < 0) || (fTimes > 10000))
				{
					goto LABEL2;
				}
			}
			bReadNext = reader.ReadBit();
			if (bReadNext)
			{
				parser.ReadPackedVector<100, 30>(Fv, reader);
			}
			bReadNext = reader.ReadBit();
			if (bReadNext)
			{
				parser.ReadPackedVector<1, 24>(fvVel, reader);
			}
			bReadNext = reader.ReadBit();
			if (bReadNext)
			{
				reader.ReadByteData((BYTE *)&nTemp, 2);
				reader.ReadByteData((BYTE *)&nTemp, 4);
			}
			bReadNext = reader.ReadBit();
			if (bReadNext)
			{
				parser.ReadPackedVector<1, 24>(fvVel, reader);
			}
			if (((reader.nPos - nPosTemp + 1) == nBunchLen) || ((reader.nPos - nPosTemp) == nBunchLen))
			{
				if ((Fv.X > 10000) && (Fv.X < 800000) && (Fv.Y > 10000) && (Fv.Y < 800000) && (Fv.Z > -1000) && (Fv.Z < 150001))
				{
					if (container->user->m_myActor.bDraw == false)
					{
						container->user->m_myActor.bDraw = true;
					}
					if (ChangeMyActorPlace(container,container->user->m_myActor.fXPos, container->user->m_myActor.fYPos, container->user->m_myActor.fZPos, Fv.X, Fv.Y, Fv.Z))
					{
						container->user->m_myActor.fXPos = Fv.X;
						container->user->m_myActor.fYPos = Fv.Y;
						container->user->m_myActor.fZPos = Fv.Z;
					}
					if (container->user->m_nChangeCnt > 3)
					{
						container->user->m_myActor.fXPos = Fv.X;
						container->user->m_myActor.fYPos = Fv.Y;
						container->user->m_myActor.fZPos = Fv.Z;
					}
					container->user->m_myActor.nType = 0;
					continue;
				}
			}
		}
	LABEL2:
		reader.nPos = j;
		reader.ReadByteData(&byteFilterHeader, 1);
		if ((byteFilterHeader == 0x4C))
		{
			reader.SerializeIntPacked(nBunchLen);
			if (nBunchLen == 102)
			{
				nBunchLen = nBunchLen;
			}
			nPosTemp = reader.nPos;
			bReadNext = reader.ReadBit();
			if (bReadNext)
			{
				parser.ReadPackedVector<1, 27>(Fv, reader);
			}
			bReadNext = reader.ReadBit();
			if (bReadNext)
			{
				reader.ReadByteData((BYTE *)&nTemp, 2);
				nTemp = nTemp & 0xFFFF;
				reader.ReadByteData((BYTE *)&nTemp, 2);
				nTemp = nTemp & 0xFFFF;
			}
			if (((reader.nPos - nPosTemp) == nBunchLen))
			{
				if ((Fv.X > 10000) && (Fv.X < 800000) && (Fv.Y > 10000) && (Fv.Y < 800000) && (Fv.Z > -10000) && (Fv.Z < 150001))
				{
					container->user->m_fMyDirYaw = (float)(nTemp) / (65535.0) * 360;
				}
			}
		}

	}
}


void LocalListener::RecvPacketFilter(user_container * container,LPBYTE pBuf, int nBuflen, int nArNum, DWORD * BunchPackID)
{
	int i = 0;
	int j = 0;
	CBitReader reader;
	
	memcpy(reader.Buffer, pBuf, nBuflen);
	reader.nNum = nBuflen * 8;
	reader.nPos = 0;
	
	CReceiveDataParsing parser;
	parser.ReceivedPacket_sub_218A5B8(reader, container);
	return;
}
user_shared_container *LocalListener::getOrCreateSharedContainer(user_container *container,int userid) {
	pthread_mutex_lock(&containerslock);

	auto itr = containers.find(userid);
	if (itr == containers.end()) {
		user_shared_container	*r = new user_shared_container();
		memset(r, 0x00, sizeof(user_shared_container));
		containers.insert( std::make_pair(userid,r) );
		container->user = r;

		if ((container->distrbute_sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
			fprintf(stderr, "socket() failed: %s\n", strerror(errno));
		}
		pthread_create(&container->user->drawThread, NULL, DrawThread, (void*)container);
		pthread_mutex_unlock(&containerslock);

		return r;
	}

	container->user = itr->second;
	pthread_mutex_unlock(&containerslock);

	return itr->second;
}


int LocalListener::My_6633EncKeyMake_sub_B164C(char* a1, int a2, char* a3)
{
	char* v3 = 0; // r3@5
	unsigned int v4 = 0; // r4@6
	unsigned int v5 = 0; // r0@11
	unsigned int v6 = 0; // r1@12
	unsigned int v7 = 0; // r5@12
	unsigned int v8 = 0; // r4@12
	unsigned int v9 = 0; // r5@12
	unsigned int v10 = 0; // r4@12
	unsigned int v11 = 0; // r4@12
	unsigned int v12 = 0; // r5@12
	unsigned int v13 = 0; // r4@12
	signed int result = 0; // r0@13
	unsigned int v15 = 0; // r0@16
	unsigned int v16 = 0; // r2@17
	unsigned int v17 = 0; // r5@17
	unsigned int v18 = 0; // r4@17
	unsigned int v19 = 0; // r5@17
	unsigned int v20 = 0; // r4@17
	unsigned int v21 = 0; // r4@17
	unsigned int v22 = 0; // r5@17
	unsigned int v23 = 0; // r4@17
	unsigned int v24 = 0; // r5@17
	unsigned int v25 = 0; // r4@17
	unsigned int v26 = 0; // r5@18
	unsigned int v27 = 0; // r4@18
	unsigned int v28 = 0; // r4@20
	unsigned int v29 = 0; // r1@21
	unsigned int v30 = 0; // r5@21
	unsigned int v31 = 0; // r0@21
	unsigned int v32 = 0; // r5@21
	unsigned int v33 = 0; // r0@21
	unsigned int v34 = 0; // r0@21
	unsigned int v35 = 0; // r5@21
	unsigned int v36 = 0; // r0@21
	unsigned int v37 = 0; // r5@21
	unsigned int v38 = 0; // r0@21
	unsigned int v39 = 0; // r0@22
	unsigned int v40 = 0;
	unsigned int v41 = 0; // r0@22
	unsigned int v42 = 0; // r5@22
	unsigned int v43 = 0; // r0@22

	if (a1 && a3)
	{
		if ((a2 & 0xFFFFFFBF) != 128 && a2 != 256)
		{
			result = -2;
		}
		else
		{
			v3 = a3;
			if (a2 == 128)
			{
				v4 = 10;
			}
			else if (a2 == 192)
			{
				v4 = 12;
			}
			else
			{
				v4 = 14;
			}


			*(DWORD *)(a3 + 240) = v4;
			*(DWORD *)a3 = ((*(BYTE *)(a1 + 1) << 16) | (*(BYTE *)a1 << 24)) ^ *(BYTE *)(a1 + 3) | (*(BYTE *)(a1 + 2) << 8);
			*(DWORD *)(a3 + 4) = ((*(BYTE *)(a1 + 5) << 16) | (*(BYTE *)(a1 + 4) << 24)) ^ *(BYTE *)(a1 + 7) | (*(BYTE *)(a1 + 6) << 8);
			*(DWORD *)(a3 + 8) = ((*(BYTE *)(a1 + 9) << 16) | (*(BYTE *)(a1 + 8) << 24)) ^ *(BYTE *)(a1 + 11) | (*(BYTE *)(a1 + 10) << 8);
			*(DWORD *)(a3 + 12) = ((*(BYTE *)(a1 + 13) << 16) | (*(BYTE *)(a1 + 12) << 24)) ^ *(BYTE *)(a1 + 15) | (*(BYTE *)(a1 + 14) << 8);
			if (a2 == 128)
			{
				v5 = 0;
				while (1)
				{
					v6 = *(DWORD *)(v3 + 12);
					v7 = dword_30CE28[v5];
					++v5;
					v8 = v7 ^ *(DWORD *)v3;
					v9 = *(DWORD *)(v3 + 4);
					v10 = v8 ^ dword_30CE28[(unsigned char)v6 + 10] & 0xFF00 ^ LOBYTE(dword_30CE28[(v6 >> 24) + 266]) ^ dword_30CE28[((v6 >> 16) & 0xFF) + 522] & 0xFF000000 ^ dword_30CE28[((unsigned short)v6 >> 8) + 778] & 0xFF0000;
					*(DWORD *)(v3 + 16) = v10;
					v11 = v10 ^ v9;
					v12 = *(DWORD *)(v3 + 8);
					*(DWORD *)(v3 + 20) = v11;
					v13 = v11 ^ v12;
					*(DWORD *)(v3 + 24) = v13;
					*(DWORD *)(v3 + 28) = v13 ^ v6;
					if (v5 == 10)
						break;
					v3 += 16;
				}
			}
			else
			{
				*(DWORD *)(a3 + 16) = ((*(unsigned char *)(a1 + 17) << 16) | (*(unsigned char *)(a1 + 16) << 24)) ^ *(unsigned char *)(a1 + 19) | (*(unsigned char *)(a1 + 18) << 8);
				*(DWORD *)(a3 + 20) = ((*(unsigned char *)(a1 + 21) << 16) | (*(unsigned char *)(a1 + 20) << 24)) ^ *(unsigned char *)(a1 + 23) | (*(unsigned char *)(a1 + 22) << 8);
				if (a2 == 192)
				{
					v15 = 0;
					while (1)
					{
						v16 = *(DWORD *)(v3 + 20);
						v17 = dword_30CE28[v15];
						++v15;
						v18 = v17 ^ *(DWORD *)v3;
						v19 = *(DWORD *)(v3 + 4);
						v20 = v18 ^ dword_30CE28[(unsigned char)v16 + 10] & 0xFF00 ^ LOBYTE(dword_30CE28[(v16 >> 24) + 266]) ^ dword_30CE28[((v16 >> 16) & 0xFF) + 522] & 0xFF000000 ^ dword_30CE28[((unsigned short)v16 >> 8) + 778] & 0xFF0000;
						*(DWORD *)(v3 + 24) = v20;
						v21 = v20 ^ v19;
						v22 = *(DWORD *)(v3 + 8);
						*(DWORD *)(v3 + 28) = v21;
						v23 = v21 ^ v22;
						v24 = *(DWORD *)(v3 + 12);
						*(DWORD *)(v3 + 32) = v23;
						v25 = v23 ^ v24;
						*(DWORD *)(v3 + 36) = v25;
						if (v15 == 8)
							break;
						v26 = *(DWORD *)(v3 + 16);
						v3 += 24;
						v27 = v25 ^ v26;
						*(DWORD *)(v3 + 16) = v27;
						*(DWORD *)(v3 + 20) = v16 ^ v27;
					}
				}
				else
				{
					*(DWORD *)(a3 + 24) = ((*(unsigned char *)(a1 + 25) << 16) | (*(unsigned char *)(a1 + 24) << 24)) ^ *(unsigned char *)(a1 + 27) | (*(unsigned char *)(a1 + 26) << 8);
					*(DWORD *)(a3 + 28) = ((*(unsigned char *)(a1 + 29) << 16) | (*(unsigned char *)(a1 + 28) << 24)) ^ *(unsigned char *)(a1 + 31) | (*(unsigned char *)(a1 + 30) << 8);
					if (a2 == 256)
					{
						v28 = 0;
						while (1)
						{
							v29 = *(DWORD *)(v3 + 28);
							v30 = dword_30CE28[v28];
							++v28;
							v31 = v30 ^ *(DWORD *)v3;
							v32 = *(DWORD *)(v3 + 4);
							v33 = v31 ^ dword_30CE28[(unsigned char)v29 + 10] & 0xFF00 ^ LOBYTE(dword_30CE28[(v29 >> 24) + 266]) ^ dword_30CE28[((v29 >> 16) & 0xFF) + 522] & 0xFF000000 ^ dword_30CE28[((unsigned short)v29 >> 8) + 778] & 0xFF0000;
							*(DWORD *)(v3 + 32) = v33;
							v34 = v33 ^ v32;
							v35 = *(DWORD *)(v3 + 8);
							*(DWORD *)(v3 + 36) = v34;
							v36 = v34 ^ v35;
							v37 = *(DWORD *)(v3 + 12);
							*(DWORD *)(v3 + 40) = v36;
							v38 = v36 ^ v37;
							*(DWORD *)(v3 + 44) = v38;
							if (v28 == 7)
								break;
							v3 += 32;
							v39 = *(DWORD *)(v3 - 16) ^ dword_30CE28[(v38 >> 24) + 522] & 0xFF000000 ^ LOBYTE(dword_30CE28[(unsigned char)v38 + 266]) ^ dword_30CE28[((v38 >> 16) & 0xFF) + 778] & 0xFF0000 ^ dword_30CE28[((unsigned short)v38 >> 8) + 10] & 0xFF00;
							v40 = *(DWORD *)(v3 - 12);
							*(DWORD *)(v3 + 16) = v39;
							v41 = v39 ^ v40;
							v42 = *(DWORD *)(v3 - 8);
							*(DWORD *)(v3 + 20) = v41;
							v43 = v41 ^ v42;
							*(DWORD *)(v3 + 24) = v43;
							*(DWORD *)(v3 + 28) = v29 ^ v43;
						}
					}
				}
			}
			result = 0;
		}
	}
	else
	{
		result = -1;
	}
	return result;
}

int LocalListener::My_6633DecKeyMake_sub_B1954(char* a1, int a2, char* a3)
{
	char* v3 = 0; // r4@1
	signed int result = 0; // r0@1
	unsigned int v5 = 0; // r3@2
	char* v6 = 0; // r0@2
	char* v7 = 0; // r1@2
	unsigned int v8 = 0; // r2@2
	unsigned int v9 = 0; // r6@2
	unsigned int i = 0; // r3@2
	unsigned int v11 = 0; // r7@4
	unsigned int v12 = 0; // r7@4
	unsigned int v13 = 0; // r7@4
	unsigned int v14 = 0; // r7@4
	unsigned int v15 = 0; // r5@5
	unsigned int v16 = 0; // t1@7
	unsigned int v17 = 0; // r2@7
	unsigned int v18 = 0; // r2@7
	unsigned int v19 = 0; // r2@7

	LPDWORD dword_30DF20 = &dword_30CE28[1086];

	v3 = a3;
	result = My_6633EncKeyMake_sub_B164C(a1, a2, a3);
	if (result >= 0)
	{
		v5 = *(DWORD *)(v3 + 240);
		v6 = v3;
		v7 = v3;
		v8 = 0;
		v9 = 4 * v5;
		char* i = v3 + 16 * v5;
		for (; ; )
		{
			v7 += 16;
			i -= 16;
			if (v8 >= v9 - v8)
				break;
			v11 = *(DWORD *)(v7 - 16);
			v8 += 4;
			*(DWORD *)(v7 - 16) = *(DWORD *)(i + 16);
			*(DWORD *)(i + 16) = v11;
			v12 = *(DWORD *)(v7 - 12);
			*(DWORD *)(v7 - 12) = *(DWORD *)(i + 20);
			*(DWORD *)(i + 20) = v12;
			v13 = *(DWORD *)(v7 - 8);
			*(DWORD *)(v7 - 8) = *(DWORD *)(i + 24);
			*(DWORD *)(i + 24) = v13;
			v14 = *(DWORD *)(v7 - 4);
			*(DWORD *)(v7 - 4) = *(DWORD *)(i + 28);
			*(DWORD *)(i + 28) = v14;
		}
		v15 = 1;
		int max = *(DWORD *)(v3 + 240);
		while (v15 < max)
		{
			v16 = *(DWORD *)(v6 + 16);
			v6 += 16;
			++v15;
			*(DWORD *)v6 = dword_30DF20[(int)(LOBYTE(dword_30CE28[(unsigned char)v16 + 266]) - 52)] ^ dword_30DF20[LOBYTE(dword_30CE28[((v16 >> 24) & 0xFF) + 266]) + 204] ^ dword_30DF20[LOBYTE(dword_30CE28[((v16 >> 16) & 0xFF) + 266]) + 460] ^ dword_30DF20[LOBYTE(dword_30CE28[(((unsigned short)v16 >> 8) & 0xFF) + 266]) + 716];
			v17 = *(DWORD *)(v6 + 4);
			*(DWORD *)(v6 + 4) = dword_30DF20[(int)(LOBYTE(dword_30CE28[(unsigned char)v17 + 266]) - 52)] ^ dword_30DF20[LOBYTE(dword_30CE28[((v17 >> 24) & 0xFF) + 266]) + 204] ^ dword_30DF20[LOBYTE(dword_30CE28[((v17 >> 16) & 0xFF) + 266]) + 460] ^ dword_30DF20[LOBYTE(dword_30CE28[(((unsigned short)v17 >> 8) & 0xFF) + 266]) + 716];
			v18 = *(DWORD *)(v6 + 8);
			*(DWORD *)(v6 + 8) = dword_30DF20[(int)(LOBYTE(dword_30CE28[(unsigned char)v18 + 266]) - 52)] ^ dword_30DF20[LOBYTE(dword_30CE28[((v18 >> 24) & 0xFF) + 266]) + 204] ^ dword_30DF20[LOBYTE(dword_30CE28[((v18 >> 16) & 0xFF) + 266]) + 460] ^ dword_30DF20[LOBYTE(dword_30CE28[(((unsigned short)v18 >> 8) & 0xFF) + 266]) + 716];

			v19 = *(DWORD *)(v6 + 12);
			*(DWORD *)(v6 + 12) = dword_30DF20[(int)(LOBYTE(dword_30CE28[(unsigned char)v19 + 266]) - 52)] ^ dword_30DF20[LOBYTE(dword_30CE28[((v19 >> 24) & 0xFF) + 266]) + 204] ^ dword_30DF20[LOBYTE(dword_30CE28[((v19 >> 16) & 0xFF) + 266]) + 460] ^ dword_30DF20[LOBYTE(dword_30CE28[(((unsigned short)v19 >> 8) & 0xFF) + 266]) + 716];
		}
		result = 0;
	}
	return result;
}

int LocalListener::My_6633EncDecKeyMake_B3BD4(char* szEncDecKeyBuffer, char* szEncDecKeyMakeKey, int a3)
{
	char* v3; // r6@1
	int v4; // r4@1
	char* v5; // r5@1
	int result; // r0@5

	v3 = szEncDecKeyMakeKey;
	v4 = a3;
	v5 = szEncDecKeyBuffer;
	if (szEncDecKeyBuffer && szEncDecKeyMakeKey)
	{
		if ((a3 & 0xFFFFFFBF) != 128 && a3 != 256)
		{
			result = -2;
		}
		else
		{
			result = My_6633EncKeyMake_sub_B164C(szEncDecKeyMakeKey, a3, szEncDecKeyBuffer);
			if (!result)
				result = My_6633DecKeyMake_sub_B1954(szEncDecKeyMakeKey, a3, szEncDecKeyBuffer + 244);
		}
	}
	else
	{
		result = -1;
	}

	return  result;
}
void LocalListener::printTcpPacket(user_container *container, const char *data, int length)
{
	char *pAddr = NULL;



	if (length - 0x19 > 1024)
	{
		return;
	}

	if ((*(unsigned int*)data == 0x0A006633) && (*(unsigned int*)(data + 5) == 0x0102100A))
	{
		memcpy(container->user->g_sz3366PacketDecodeKeyMakeKey, (data + 0x17), 0x10);
		My_6633EncDecKeyMake_B3BD4(container->user->g_sz3366PacketDecodeKey, container->user->g_sz3366PacketDecodeKeyMakeKey, 128);

	}
	if ((*(unsigned int*)data == 0x0A006633))
	{
		if ((*(unsigned int*)(data + 5) == 0x0113400A))
		{
			char szEncodedSrc[2048] = { '\0' };
			char szDecodedDst[2048] = { '\0' };
			char szPakcetHeader[0xFF] = { '\0' };
			int nPakcetHeaderLen = 0;
			int nStrLen = 0;
			int nReadIndex = 0;
			int nPacketLen = *(unsigned short*)(data + 0x14); //+20
			int nStartDecData = *(unsigned short*)(data + 0x10); //+16??



			memcpy(szEncodedSrc, (data + nStartDecData), nPacketLen);
			Mydecode6633Packet_sub_C1520(container->user->g_sz3366PacketDecodeKey, szEncodedSrc, nPacketLen, szDecodedDst);

			if ((szDecodedDst[0] == 0x78) && (szDecodedDst[1] == 0x03))
			{
				nPakcetHeaderLen = (int)(szDecodedDst[2]);
				memcpy(szPakcetHeader, szDecodedDst + 3, nPakcetHeaderLen);
				szPakcetHeader[nPakcetHeaderLen] = 0x00;
				nReadIndex = 3 + nPakcetHeaderLen;
				printf("szPakcetHeader:%s\n", szPakcetHeader);
				if (strcmp(szPakcetHeader, "enter_game") == 0
					|| strcmp(szPakcetHeader, "re_enter_game") == 0
					)
				{
					printf("found enter completed!!\n");

					//g_PubgRadar.ResetVariable();
					if (szDecodedDst[nReadIndex] != 0x03)
						return;

					nStrLen = (int)(szDecodedDst[nReadIndex + 1]);
					//g_PubgRadar.ClearActors();
					//memset(g_szGameServerIpAddr, 0, 256);
					//memcpy(g_szGameServerIpAddr, szDecodedDst + nReadIndex + 2, nStrLen);
					//list_ip = gethostbyname(g_szGameServerIpAddr);
					//HOSTENT *host = gethostbyname(g_szGameServerIpAddr);
					//g_nIpCnt = 0;
					/*for (int i = 0;; i++)
					{
					pAddr = inet_ntoa(*(IN_ADDR*)host->h_addr_list[i]);
					g_dwMainIp1[i] = ChangeIpAddrToDWORD(pAddr);
					g_nIpCnt++;
					if (host->h_addr_list[i] + host->h_length >= host->h_name)
					break;
					}*/
					nReadIndex += 2;
					nReadIndex += nStrLen;
					nReadIndex += 10;

					if (szDecodedDst[nReadIndex] != 0x03)
						return;


					

					nStrLen = (int)(szDecodedDst[nReadIndex + 1]);
					memcpy(container->user->g_szGamePacketKey01, szDecodedDst + nReadIndex + 2, nStrLen);
					nReadIndex += 2;
					nReadIndex += nStrLen;

					if (szDecodedDst[nReadIndex] != 0x02)
						return;
					memcpy(container->user->g_szGamePacketKey02, szDecodedDst + nReadIndex + 1, 12);

					decode_s64(&container->user->g_ullDecodeKey, container->user->g_szGamePacketKey02, 12);
					container->user->g_ullDecodeKey += 246;
					
					int c = 5;
					DecodeUDPPacketKeyMake_F12E3C(container);
					c = 6;


				}
			}
		}
	}
}
void LocalListener::DecodeUDPPacketKeyMake_F12E3C(user_container *container)
{
	char* v39;
	unsigned int v40;
	unsigned short v41;
	char* v42;
	short v43;
	unsigned int v44;
	unsigned int v45;
	unsigned short v46;

	v39 = container->user->g_szGamePacketKey01;
	v40 = 0;

	v41 = *(unsigned char*)v39;
	if (*(unsigned char*)v39)
	{
		v42 = v39 + 1;
		v40 = 0;
		do
		{
			v43 = towupper(v41);
			v44 = dword_3D0EF10[(uint8_t)(v43 ^ v40)] ^ (v40 >> 8);
			v45 = dword_3D0EF10[(uint8_t)(v44 ^ HIBYTE(v43))];
			v46 = *(unsigned char*)v42;

			++v42;
			v41 = v46;
			v40 = v45 ^ (v44 >> 8);
		} while (v46);
	}

	unsigned int R0 = v40;
	unsigned int R1 = (DWORD)(LODWORD(container->user->g_ullDecodeKey) + 23 * HIDWORD(container->user->g_ullDecodeKey));

	int _R12 = -2092037281;
	int v3 = 0;
	int v4 = 0;
	int64_t ullTemp = 0;
	int R7 = 0;
	int R5 = 0;
	unsigned int v10 = 0;
	char * v11 = 0;
	char * v13 = 0;

	char* byte_3F213A0_Addr = container->user->g_szPacketDecodeKey_3F213A0;
	char* byte_3F21350_Addr = container->user->g_szPacketDecodeKey_3F21350;
	do
	{
		ullTemp = (LONGLONG)((signed int)R0) * (LONGLONG)_R12;
		signed int p1 = (signed int)R0;
		signed int p2 = ullTemp >> 32;
		R7 = p2 + p1;
		v10 = (unsigned int)((signed int)R7 >> 16) + ((unsigned int)R7 >> 31);
		v11 = (char *)byte_3F213A0_Addr + v4++;
		R0 = (unsigned int)(-2836) * (unsigned int)v10 + 16807 * (R0 - 127773 * (unsigned int)v10);
		if ((signed int)R0 <= 0)
			R0 += 0x7FFFFFFF;
		*(char*)v11 = R0 ^ (R0 >> 8) ^ (R0 >> 16) ^ (R0 >> 24);
	} while (v4 != 32);
	do
	{
		ullTemp = (LONGLONG)((signed int)R1) * (LONGLONG)_R12;
		R5 = ((ullTemp >> 32) + (signed int)R1);
		v13 = (char *)byte_3F21350_Addr + v3++;
		R1 = (unsigned int)(-2836) * (unsigned int)((unsigned int)((signed int)R5 >> 16) + ((unsigned int)R5 >> 31)) + 16807 * (unsigned int)(R1 - 127773 * ((unsigned int)((signed int)R5 >> 16) + ((unsigned int)R5 >> 31)));
		if ((signed int)R1 <= 0)
			R1 += 0x7FFFFFFF;
		*(char*)v13 = R1 ^ (R1 >> 8) ^ (R1 >> 16) ^ (R1 >> 24);

	} while (v3 != 12);

	container->user->g_bPacketDecode_3F21303 = true;
}


int LocalListener::decode_u64(uint64_t *a1, char *a2, unsigned int a3)
{
	char *v3; // r4@1
	int v4; // r5@1
	uint64_t v5; // r8@1
	char v6; // t1@4

	v3 = a2;
	v4 = 0;
	v5 = 0LL;
	while (v3 < &a2[a3] && v4 != 70)
	{
		v6 = *v3++;
		v5 |= (uint64_t)(v6 & 0x7F) << v4;
		if (!(v6 & 0x80))
		{
			*a1 = v5;
			return v3 - a2;
		}
		v4 += 7;
	}
	return 0;
}
int LocalListener::decode_s64(int64_t *a1, char *a2, unsigned int a3)
{
	int64_t *v3; // r5@1
	int result; // r0@1
	uint64_t v5; // r2@2
	int v6; // off@2
	bool v7; // cf@5
	uint64_t v8; // [sp+0h] [bp-28h]@1


	v3 = a1;
	v8 = 0LL;

	result = decode_u64(&v8, a2, a3);
	if (result)
	{
		v5 = v8 / 2;
		if (v8 & 1)
		{
			if (!v5)
				v5 = 0x8000000000000000LL;
			v8 = v5;
			v7 = (unsigned int)v5 <= 0;
			*(DWORD*)((DWORD)(&v5) + 0) = -(signed int)v5;
			*(DWORD*)((DWORD)(&v5) + 4) -= 2 * HIDWORD(v5) + !v7;
		}
		v8 = v5;
		*v3 = v5;
	}

	return result;
}
int LocalListener::Mydecode6633Packet_sub_C1520(char* szEncDecKeyBuffer, char* szEncodedSrc, int nSrcLen, char *szDecodedDest)
{
	int nResult = 1; // r4@7

	if (szEncDecKeyBuffer)
	{
		if (szEncodedSrc && nSrcLen && szDecodedDest)
		{
			MyDec_6633Packet_sub_B3B28(szEncodedSrc, nSrcLen, szEncDecKeyBuffer, szDecodedDest);
		}
		else
		{
			nResult = -2;
		}
	}
	else
	{
		nResult = -1;
	}

	return  nResult;
}
int LocalListener::MyDec_6633Packet_sub_B3B28(char* szEncodeSrc, int nSrcLen, char* szEncDecKeyBuffer, char* szDecodedDest)
{
	char* v5; // r6@1
	int v6; // r4@1
	char* v7; // r3@8
	int v8; // r2@13
	int v9; // r4@13
	int v10; // r3@14
	int v11; // r3@15
	signed int result; // r0@18

	v5 = szDecodedDest;
	v6 = nSrcLen;
	if (szEncDecKeyBuffer && szEncodeSrc && szDecodedDest && nSrcLen && !(nSrcLen & 0xF))
	{
		MyDec_6633Packet_sub_B3888(szEncodeSrc, szDecodedDest, nSrcLen, szEncDecKeyBuffer + 244, byte_30EF50, 0);
		v7 = v5 + v6;
		if (*(char *)(v5 + v6 - 6) != 116
			|| *(char *)(v7 - 5) != 115
			|| *(char *)(v7 - 4) != 102
			|| *(char *)(v7 - 3) != 52
			|| *(char *)(v7 - 2) != 103)
		{
			result = -3;
		}
		else
		{
			v8 = *(char *)(v7 - 1);
			v9 = v6 - v8;
			if (v9 <= 0)
			{
				result = -4;
			}
			else
			{
				v10 = v9 & 0xF;
				if (v10 <= 10)
					v11 = 16 - v10;
				else
					v11 = 32 - v10;
				if (v11 == v8)
				{
					result = 0;
				}
				else
				{
					result = -5;
				}
			}
		}
	}
	else
	{
		result = -1;
	}
	return result;
}

char* LocalListener::MyDec_6633Packet_sub_B2984(char* a1, char* a2, char* a3)
{
	signed int v3;
	unsigned int v4;
	unsigned int v5;
	unsigned int v6;
	unsigned int v7;
	unsigned int v8;
	unsigned int v9;
	unsigned int v10;
	unsigned int v11;
	unsigned int v12;
	unsigned int v13;
	unsigned int v14;
	unsigned int v15;
	unsigned int v16;
	unsigned int v17;
	unsigned int v18;
	unsigned int v19;
	unsigned int v20;
	unsigned int v21;
	unsigned int v22;
	unsigned int v23;
	unsigned int v24;
	unsigned int v25;
	unsigned int v26;
	unsigned int v27;
	unsigned int v28;
	unsigned int v29;
	unsigned int v30;
	unsigned int v31;
	unsigned int v32;
	unsigned int v33;
	unsigned int v34;
	unsigned int v35;
	unsigned int v36;
	unsigned int v37;
	int v38;
	unsigned int v39;
	unsigned int v40;
	unsigned int v41;
	unsigned int v42;
	unsigned int v43;
	unsigned int v44;
	unsigned int v45;
	unsigned int v46;
	unsigned int v47;
	unsigned int v48;
	unsigned int v49;
	unsigned int v50;
	unsigned int v51;
	unsigned int v52;
	char* result;
	unsigned int v54;
	unsigned int v55;
	unsigned int v56;
	unsigned int v57;
	int v58;
	unsigned int v59;

	LPDWORD dword_30DF20 = &dword_30CE28[1086];
	v3 = *(DWORD *)(a3 + 240);
	v4 = ((((*(unsigned char *)(a1 + 1) << 16) & 0x00FF0000) | ((*(unsigned char *)a1 << 24) & 0xFF000000)) ^ (*(unsigned char *)(a1 + 3) & 0x000000FF) | ((*(unsigned char *)(a1 + 2) << 8) & 0x0000FF00)) ^ *(DWORD *)a3;
	v5 = ((((*(unsigned char *)(a1 + 5) << 16) & 0x00FF0000) | ((*(unsigned char *)(a1 + 4) << 24) & 0xFF000000)) ^ (*(unsigned char *)(a1 + 7) & 0x000000FF) | ((*(unsigned char *)(a1 + 6) << 8) & 0x0000FF00)) ^ *(DWORD *)(a3 + 4);
	v6 = ((((*(unsigned char *)(a1 + 9) << 16) & 0x00FF0000) | ((*(unsigned char *)(a1 + 8) << 24) & 0xFF000000)) ^ (*(unsigned char *)(a1 + 11) & 0x000000FF) | ((*(unsigned char *)(a1 + 10) << 8) & 0x0000FF00)) ^ *(DWORD *)(a3 + 8);
	v7 = ((((*(unsigned char *)(a1 + 13) << 16) & 0x00FF0000) | ((*(unsigned char *)(a1 + 12) << 24) & 0xFF000000)) ^ (*(unsigned char *)(a1 + 15) & 0x000000FF) | ((*(unsigned char *)(a1 + 14) << 8) & 0x0000FF00)) ^ *(DWORD *)(a3 + 12);

	v8 = dword_30DF20[((v4 >> 24) & 0xFF) + 204] ^ dword_30DF20[(unsigned char)(*(unsigned char *)(a1 + 7) ^ *(unsigned char *)(a3 + 4)) - 52] ^ *(DWORD *)(a3 + 16) ^ dword_30DF20[((v7 >> 16) & 0xFF) + 460] ^ dword_30DF20[(((WORD)(_byteswap_ushort(*(WORD *)(a1 + 10)) ^ *(WORD *)(a3 + 8)) >> 8) & 0xFF) + 716];
	v9 = dword_30DF20[((v5 >> 24) & 0xFF) + 204] ^ dword_30DF20[((unsigned char)v6 - 52)] ^ *(DWORD *)(a3 + 20) ^ dword_30DF20[((v4 >> 16) & 0xFF) + 460] ^ dword_30DF20[(((WORD)(_byteswap_ushort(*(WORD *)(a1 + 14)) ^ *(WORD *)(a3 + 12)) >> 8) & 0xFF) + 716];
	v10 = dword_30DF20[((v6 >> 24) & 0xFF) + 204] ^ dword_30DF20[((unsigned char)v7 - 52)] ^ *(DWORD *)(a3 + 24) ^ dword_30DF20[((v5 >> 16) & 0xFF) + 460] ^ dword_30DF20[(((WORD)(_byteswap_ushort(*(WORD *)(a1 + 2)) ^ *(WORD *)a3) >> 8) & 0xFF) + 716];
	v11 = dword_30DF20[((v7 >> 24) & 0xFF) + 204] ^ dword_30DF20[((unsigned char)v4 - 52)] ^ *(DWORD *)(a3 + 28) ^ dword_30DF20[((v6 >> 16) & 0xFF) + 460] ^ dword_30DF20[(((WORD)(_byteswap_ushort(*(WORD *)(a1 + 6)) ^ *(WORD *)(a3 + 4)) >> 8) & 0xFF) + 716];
	v12 = dword_30DF20[((v8 >> 24) & 0xFF) + 204] ^ dword_30DF20[((unsigned char)v9 - 52)] ^ *(DWORD *)(a3 + 32) ^ dword_30DF20[((v11 >> 16) & 0xFF) + 460] ^ dword_30DF20[(((WORD)v10 >> 8) & 0xFF) + 716];
	v13 = dword_30DF20[((v9 >> 24) & 0xFF) + 204] ^ dword_30DF20[((unsigned char)v10 - 52)] ^ *(DWORD *)(a3 + 36) ^ dword_30DF20[((v8 >> 16) & 0xFF) + 460] ^ dword_30DF20[(((WORD)v11 >> 8) & 0xFF) + 716];
	v14 = dword_30DF20[((v10 >> 24) & 0xFF) + 204] ^ dword_30DF20[((unsigned char)v11 - 52)] ^ *(DWORD *)(a3 + 40) ^ dword_30DF20[((v9 >> 16) & 0xFF) + 460] ^ dword_30DF20[(((WORD)v8 >> 8) & 0xFF) + 716];

	v15 = dword_30DF20[(v11 >> 24) + 204] ^ dword_30DF20[(unsigned char)v8 - 52] ^ *(DWORD *)(a3 + 44) ^ dword_30DF20[((v10 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v9 >> 8) + 716];
	v16 = dword_30DF20[(v12 >> 24) + 204] ^ dword_30DF20[((unsigned char)v13 - 52)] ^ *(DWORD *)(a3 + 48) ^ dword_30DF20[((v15 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v14 >> 8) + 716];
	v17 = dword_30DF20[(v13 >> 24) + 204] ^ dword_30DF20[(unsigned char)v14 - 52] ^ *(DWORD *)(a3 + 52) ^ dword_30DF20[((v12 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v15 >> 8) + 716];
	v18 = dword_30DF20[(v14 >> 24) + 204] ^ dword_30DF20[(unsigned char)v15 - 52] ^ *(DWORD *)(a3 + 56) ^ dword_30DF20[((v13 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v12 >> 8) + 716];
	v19 = dword_30DF20[(v15 >> 24) + 204] ^ dword_30DF20[((unsigned char)v12 - 52)] ^ *(DWORD *)(a3 + 60) ^ dword_30DF20[((v14 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v13 >> 8) + 716];
	v20 = dword_30DF20[(v16 >> 24) + 204] ^ dword_30DF20[(unsigned char)v17 - 52] ^ *(DWORD *)(a3 + 64) ^ dword_30DF20[((v19 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v18 >> 8) + 716];
	v21 = dword_30DF20[(v17 >> 24) + 204] ^ dword_30DF20[(unsigned char)v18 - 52] ^ *(DWORD *)(a3 + 68) ^ dword_30DF20[((v16 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v19 >> 8) + 716];

	v22 = dword_30DF20[(v18 >> 24) + 204] ^ dword_30DF20[(unsigned char)v19 - 52] ^ *(DWORD *)(a3 + 72) ^ dword_30DF20[((v17 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v16 >> 8) + 716];
	v23 = dword_30DF20[(v19 >> 24) + 204] ^ dword_30DF20[((unsigned char)v16 - 52)] ^ *(DWORD *)(a3 + 76) ^ dword_30DF20[((v18 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v17 >> 8) + 716];
	v24 = dword_30DF20[(v20 >> 24) + 204] ^ dword_30DF20[(unsigned char)v21 - 52] ^ *(DWORD *)(a3 + 80) ^ dword_30DF20[((v23 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v22 >> 8) + 716];
	v25 = dword_30DF20[(v21 >> 24) + 204] ^ dword_30DF20[(unsigned char)v22 - 52] ^ *(DWORD *)(a3 + 84) ^ dword_30DF20[((v20 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v23 >> 8) + 716];
	v26 = dword_30DF20[(v22 >> 24) + 204] ^ dword_30DF20[((unsigned char)v23 - 52)] ^ *(DWORD *)(a3 + 88) ^ dword_30DF20[((v21 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v20 >> 8) + 716];
	v27 = dword_30DF20[(v23 >> 24) + 204] ^ dword_30DF20[((unsigned char)v20 - 52)] ^ *(DWORD *)(a3 + 92) ^ dword_30DF20[((v22 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v21 >> 8) + 716];
	v28 = dword_30DF20[(v24 >> 24) + 204] ^ dword_30DF20[((unsigned char)v25 - 52)] ^ *(DWORD *)(a3 + 96) ^ dword_30DF20[((v27 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v26 >> 8) + 716];

	v29 = dword_30DF20[(v25 >> 24) + 204] ^ dword_30DF20[((unsigned char)v26 - 52)] ^ *(DWORD *)(a3 + 100) ^ dword_30DF20[((v24 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v27 >> 8) + 716];
	v30 = dword_30DF20[(v26 >> 24) + 204] ^ dword_30DF20[((unsigned char)v27 - 52)] ^ *(DWORD *)(a3 + 104) ^ dword_30DF20[((v25 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v24 >> 8) + 716];
	v31 = dword_30DF20[(v27 >> 24) + 204] ^ dword_30DF20[((unsigned char)v24 - 52)] ^ *(DWORD *)(a3 + 108) ^ dword_30DF20[((v26 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v25 >> 8) + 716];
	v32 = dword_30DF20[(v28 >> 24) + 204] ^ dword_30DF20[((unsigned char)v29 - 52)] ^ *(DWORD *)(a3 + 112) ^ dword_30DF20[((v31 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v30 >> 8) + 716];
	v33 = dword_30DF20[(v29 >> 24) + 204] ^ dword_30DF20[((unsigned char)v30 - 52)] ^ *(DWORD *)(a3 + 116) ^ dword_30DF20[((v28 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v31 >> 8) + 716];
	v34 = dword_30DF20[(v30 >> 24) + 204] ^ dword_30DF20[((unsigned char)v31 - 52)] ^ *(DWORD *)(a3 + 120) ^ dword_30DF20[((v29 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v28 >> 8) + 716];
	v35 = dword_30DF20[(v31 >> 24) + 204] ^ dword_30DF20[((unsigned char)v28 - 52)] ^ *(DWORD *)(a3 + 124) ^ dword_30DF20[((v30 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v29 >> 8) + 716];

	v36 = dword_30DF20[(v32 >> 24) + 204] ^ dword_30DF20[((unsigned char)v33 - 52)] ^ *(DWORD *)(a3 + 128) ^ dword_30DF20[((v35 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v34 >> 8) + 716];
	v37 = dword_30DF20[(v33 >> 24) + 204] ^ dword_30DF20[((unsigned char)v34 - 52)] ^ *(DWORD *)(a3 + 132) ^ dword_30DF20[((v32 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v35 >> 8) + 716];
	v38 = dword_30DF20[(v34 >> 24) + 204] ^ dword_30DF20[((unsigned char)v35 - 52)] ^ *(DWORD *)(a3 + 136);
	v39 = dword_30DF20[(v35 >> 24) + 204] ^ dword_30DF20[((unsigned char)v32 - 52)] ^ *(DWORD *)(a3 + 140) ^ dword_30DF20[((v34 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v33 >> 8) + 716];
	v40 = v38 ^ dword_30DF20[((v33 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v32 >> 8) + 716];
	v41 = dword_30DF20[(v36 >> 24) + 204] ^ dword_30DF20[((unsigned char)v37 - 52)] ^ *(DWORD *)(a3 + 144) ^ dword_30DF20[((v39 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v40 >> 8) + 716];
	v42 = dword_30DF20[(v37 >> 24) + 204] ^ dword_30DF20[((unsigned char)v40 - 52)] ^ *(DWORD *)(a3 + 148) ^ dword_30DF20[((v36 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v39 >> 8) + 716];
	v43 = dword_30DF20[(v40 >> 24) + 204] ^ dword_30DF20[((unsigned char)v39 - 52)] ^ *(DWORD *)(a3 + 152) ^ dword_30DF20[((v37 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v36 >> 8) + 716];
	v44 = dword_30DF20[(v39 >> 24) + 204] ^ dword_30DF20[((unsigned char)v36 - 52)] ^ *(DWORD *)(a3 + 156) ^ dword_30DF20[((v40 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v37 >> 8) + 716];

	if (v3 > 10)
	{
		v45 = dword_30DF20[(v41 >> 24) + 204] ^ dword_30DF20[(unsigned char)v42 - 52] ^ *(DWORD *)(a3 + 160) ^ dword_30DF20[((v44 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v43 >> 8) + 716];
		v46 = dword_30DF20[(v42 >> 24) + 204] ^ dword_30DF20[(unsigned char)v43 - 52] ^ *(DWORD *)(a3 + 164) ^ dword_30DF20[((v41 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v44 >> 8) + 716];
		v47 = dword_30DF20[(v43 >> 24) + 204] ^ dword_30DF20[(unsigned char)v44 - 52] ^ *(DWORD *)(a3 + 168) ^ dword_30DF20[((v42 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v41 >> 8) + 716];
		v48 = dword_30DF20[(v44 >> 24) + 204] ^ dword_30DF20[(unsigned char)v41 - 52] ^ *(DWORD *)(a3 + 172) ^ dword_30DF20[((v43 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v42 >> 8) + 716];
		v41 = dword_30DF20[(v45 >> 24) + 204] ^ dword_30DF20[(unsigned char)v46 - 52] ^ *(DWORD *)(a3 + 176) ^ dword_30DF20[((v48 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v47 >> 8) + 716];
		v42 = dword_30DF20[(v46 >> 24) + 204] ^ dword_30DF20[(unsigned char)v47 - 52] ^ *(DWORD *)(a3 + 180) ^ dword_30DF20[((v45 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v48 >> 8) + 716];
		v43 = dword_30DF20[(v47 >> 24) + 204] ^ dword_30DF20[(unsigned char)v48 - 52] ^ *(DWORD *)(a3 + 184) ^ dword_30DF20[((v46 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v45 >> 8) + 716];
		v44 = dword_30DF20[(v48 >> 24) + 204] ^ dword_30DF20[(unsigned char)v45 - 52] ^ *(DWORD *)(a3 + 188) ^ dword_30DF20[((v47 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v46 >> 8) + 716];

		if (v3 > 12)
		{
			v49 = dword_30DF20[(v41 >> 24) + 204] ^ dword_30DF20[(unsigned char)v42 - 52] ^ *(DWORD *)(a3 + 192) ^ dword_30DF20[((v44 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v43 >> 8) + 716];
			v50 = dword_30DF20[((WORD)v44 >> 8) + 716] ^ *(DWORD *)(a3 + 196) ^ dword_30DF20[(v42 >> 24) + 204] ^ dword_30DF20[v43 - 52] ^ dword_30DF20[((v41 >> 16) & 0xFF) + 460];
			v51 = dword_30DF20[(v43 >> 24) + 204] ^ dword_30DF20[(unsigned char)v44 - 52] ^ *(DWORD *)(a3 + 200) ^ dword_30DF20[((v42 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v41 >> 8) + 716];
			v52 = dword_30DF20[(v44 >> 24) + 204] ^ dword_30DF20[(unsigned char)v41 - 52] ^ *(DWORD *)(a3 + 204) ^ dword_30DF20[((v43 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v42 >> 8) + 716];
			v41 = dword_30DF20[(v49 >> 24) + 204] ^ dword_30DF20[(unsigned char)v50 - 52] ^ *(DWORD *)(a3 + 208) ^ dword_30DF20[((v52 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v51 >> 8) + 716];
			v42 = *(DWORD *)(a3 + 212) ^ dword_30DF20[(v50 >> 24) + 204] ^ dword_30DF20[(unsigned char)v51 - 52] ^ dword_30DF20[((v49 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v52 >> 8) + 716];
			v43 = dword_30DF20[(v51 >> 24) + 204] ^ dword_30DF20[(unsigned char)v52 - 52] ^ *(DWORD *)(a3 + 216) ^ dword_30DF20[((v50 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v49 >> 8) + 716];
			v44 = dword_30DF20[(v52 >> 24) + 204] ^ dword_30DF20[(unsigned char)v49 - 52] ^ *(DWORD *)(a3 + 220) ^ dword_30DF20[((v51 >> 16) & 0xFF) + 460] ^ dword_30DF20[((WORD)v50 >> 8) + 716];
		}
	}
	result = a3 + 16 * v3;
	v54 = (*((unsigned char *)dword_30DF20 + (unsigned char)v42 + 3888) | (*((unsigned char *)dword_30DF20 + (v41 >> 24) + 3888) << 24) | (*((unsigned char *)dword_30DF20 + ((v44 >> 16) & 0xFF) + 3888) << 16) | (*((unsigned char *)dword_30DF20 + ((WORD)v43 >> 8) + 3888) << 8)) ^ *(DWORD *)result;
	*(unsigned char *)(a2 + 3) = v54;
	*(unsigned char *)a2 = v54 >> 24;
	*(unsigned char *)(a2 + 1) = v54 >> 16;
	*(unsigned char *)(a2 + 2) = v54 >> 8;

	v55 = (*((unsigned char *)dword_30DF20 + (unsigned char)v43 + 3888) | ((*((unsigned char *)dword_30DF20 + (v42 >> 24) + 3888) << 24)) | ((*((unsigned char *)dword_30DF20 + ((v41 >> 16) & 0xFF) + 3888) << 16)) | ((*((unsigned char *)dword_30DF20 + ((WORD)v44 >> 8) + 3888) << 8))) ^ *(DWORD *)(result + 4);
	*(unsigned char *)(a2 + 7) = v55;
	*(unsigned char *)(a2 + 4) = v55 >> 24;
	*(unsigned char *)(a2 + 5) = v55 >> 16;
	*(unsigned char *)(a2 + 6) = v55 >> 8;
	v56 = (*((unsigned char *)dword_30DF20 + (unsigned char)v44 + 3888) | (*((unsigned char *)dword_30DF20 + (v43 >> 24) + 3888) << 24) | (*((unsigned char *)dword_30DF20 + ((v42 >> 16) & 0xFF) + 3888) << 16) | (*((unsigned char *)dword_30DF20 + ((WORD)v41 >> 8) + 3888) << 8)) ^ *(DWORD *)(result + 8);
	*(unsigned char *)(a2 + 11) = v56;
	*(unsigned char *)(a2 + 8) = v56 >> 24;
	*(unsigned char *)(a2 + 9) = v56 >> 16;
	v57 = v56 >> 8;
	v58 = *((unsigned char *)dword_30DF20 + (unsigned char)v41 + 3888);
	*(unsigned char *)(a2 + 10) = v57;
	v59 = (v58 | (*((unsigned char *)dword_30DF20 + (v44 >> 24) + 3888) << 24) | (*((unsigned char *)dword_30DF20 + ((v43 >> 16) & 0xFF) + 3888) << 16) | (*((unsigned char *)dword_30DF20 + ((WORD)v42 >> 8) + 3888) << 8)) ^ *(DWORD *)(result + 12);
	*(unsigned char *)(a2 + 12) = v59 >> 24;
	*(unsigned char *)(a2 + 13) = v59 >> 16;
	*(unsigned char *)(a2 + 15) = v59;
	*(unsigned char *)(a2 + 14) = v59 >> 8;

	return result;
}
char* LocalListener::MyDec_6633Packet_sub_B3888(char* szEncodedSrc, char* szDecodedDest, int nSrcLen, char* szDecKeyBuffer, char* a5, int a6)
{
	char* v6; // r9@1
	char* v7; // r8@1
	char* v8; // r7@1
	int v9; // r4@1
	char* v10; // r5@1
	char* v11; // r3@2
	char* i; // r11@2
	int v13; // r6@3
	int v14; // r11@3
	int v15; // r3@5
	unsigned int v16; // r0@8
	unsigned int v17; // r4@8
	int v18; // r8@8
	char* result; // r0@8
	int v20; // r3@9
	int v21; // r2@13
	unsigned int v22; // r3@17
	int v23; // r4@17
	char* v24; // r7@17
	int v25; // r3@18
	char* v26; // [sp+0h] [bp-48h]@16
	char s[16]; // [sp+Ch] [bp-3Ch]@1
	int v28; // [sp+1Ch] [bp-2Ch]@1

	v6 = szDecKeyBuffer;
	v7 = szEncodedSrc;
	v8 = szDecodedDest;
	v9 = nSrcLen;
	v10 = a5;

	memset(s, 0, 0x10);
	v11 = v8;
	for (i = v7; (unsigned int)(v7 + v9 - i) > 0xF; i += 16)
	{
		v26 = v11;
		MyDec_6633Packet_sub_B2984(i, v11, v6);
		v21 = 0;
		do
		{
			*(char *)(v26 + v21) ^= *(char *)(v10 + v21);
			++v21;
		} while (v21 != 16);
		v10 = i;
		v11 = v26 + 16;
	}
	v22 = v9 & 0xFFFFFFF0;
	v23 = v9 & 0xF;
	result = v7 + v22;
	v24 = v8 + v22;
	if (v23)
	{
		result = MyDec_6633Packet_sub_B2984(result, s, v6);
		v25 = 0;
		do
		{
			*(char *)(v24 + v25) = s[v25] ^ *(char *)(v10 + v25);
			++v25;
		} while (v25 != v23);
	}

	return result;
}
void LocalListener::GarbageCollector() {
	while (true) {

		pthread_mutex_lock(&maincontainerslock);
		if (maincontainers.size() > 0) {
			for (auto itr = maincontainers.begin(); itr != maincontainers.end(); itr++)
			{
				auto container = *itr;

				pthread_mutex_lock(&container->lock); //lock network operations
				if (container->user != nullptr)
				{
					auto timeleft = GetTickCountMs() - container->user->lastResponseTime;
					if (timeleft > 300) {
						// i found a garbaage
						// first receive thread
						//container->_running = false;
						//pthread_join(container->user->drawThread, nullptr);
						/*
						now clear everything
						*/



					}

				}
				pthread_mutex_unlock(&container->lock);


			}

		}
		
		
		pthread_mutex_unlock(&maincontainerslock);



	}
}
void LocalListener::StartAccept()
{

	
	/*auto cont = new user_container();
	memset(cont, 0x00, sizeof(user_container));
	cont->user = new user_shared_container();
	memset(cont->user, 0x00, sizeof(user_shared_container));
	strcpy(cont->user->g_szGamePacketKey01, "!30d64z$!zi72*09+x");
	strcpy(cont->user->g_szGamePacketKey02, "\xA0\xFB\xF6\xFF\xC6\x82\xE2\xC7\x02\x02\x98\x0E\x00");
	cont->user->g_ullDecodeKey = (LONGLONG)92257865552551878LL;
	DecodeUDPPacketKeyMake_F12E3C(cont);

	*/

	socklen_t cliSize = sizeof(sockaddr_in);

	while (1) {

		int sock = accept(serverSock, (struct sockaddr *) &clientAddr, &cliSize);

		if (sock < 0) {
		}
		else {
			
			user_container	*p = new user_container();
			memset(p, 0x00, sizeof(user_container));
			p->_running = true;
	
			p->lock = PTHREAD_MUTEX_INITIALIZER;
			p->socket = sock;
			arg_struct *p2 = new arg_struct();
			p2->c = p;
			p2->l = this;

			pthread_mutex_lock(&maincontainerslock);
			maincontainers.push_back(p);
			pthread_mutex_unlock(&maincontainerslock);

			pthread_create(&p->recvThread, NULL, RecvThread, (void*)p2);
		}
	}
}
